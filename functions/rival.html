<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Rival Pro â€¢ Intellectual Debate Platform</title>
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <!-- Icons -->
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons+Round" rel="stylesheet">
    <!-- TensorFlow.js -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.18.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/universal-sentence-encoder@1.3.3"></script>
    <!-- Animate.css -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css">
    <style>
        :root {
            /* Light Theme */
            --color-primary: #4361ee;
            --color-primary-dark: #3a56d4;
            --color-secondary: #7209b7;
            --color-accent: #f72585;
            --color-surface: #ffffff;
            --color-background: #f8f9fa;
            --color-on-surface: #212529;
            --color-on-primary: #ffffff;
            --color-border: #e9ecef;
            --color-success: #4cc9f0;
            --color-warning: #f8961e;
            --color-error: #ef233c;
            
            /* Elevation shadows */
            --shadow-sm: 0 1px 3px rgba(0,0,0,0.12);
            --shadow-md: 0 4px 6px rgba(0,0,0,0.1);
            --shadow-lg: 0 10px 25px rgba(0,0,0,0.1);
            --shadow-xl: 0 20px 50px rgba(0,0,0,0.15);
            
            /* Border radius */
            --radius-sm: 8px;
            --radius-md: 12px;
            --radius-lg: 16px;
            --radius-xl: 24px;
            
            /* Spacing */
            --space-xs: 4px;
            --space-sm: 8px;
            --space-md: 16px;
            --space-lg: 24px;
            --space-xl: 32px;
            
            /* Typography */
            --font-primary: 'Inter', -apple-system, sans-serif;
            --font-secondary: 'Poppins', -apple-system, sans-serif;
            --text-xs: 0.75rem;
            --text-sm: 0.875rem;
            --text-base: 1rem;
            --text-lg: 1.125rem;
            --text-xl: 1.25rem;
            --text-2xl: 1.5rem;
            --text-3xl: 1.875rem;
            --text-4xl: 2.25rem;
            
            /* Animation */
            --transition-fast: 0.15s;
            --transition-normal: 0.3s;
            --transition-slow: 0.5s;
        }
        
        [data-theme="dark"] {
            --color-primary: #4895ef;
            --color-primary-dark: #4361ee;
            --color-secondary: #b5179e;
            --color-accent: #f72585;
            --color-surface: #1a1a1a;
            --color-background: #121212;
            --color-on-surface: #e9ecef;
            --color-on-primary: #ffffff;
            --color-border: #2d2d2d;
            --color-success: #4cc9f0;
            --color-warning: #f8961e;
            --color-error: #ef233c;
            
            --shadow-sm: 0 1px 3px rgba(0,0,0,0.25);
            --shadow-md: 0 4px 6px rgba(0,0,0,0.3);
            --shadow-lg: 0 10px 25px rgba(0,0,0,0.35);
            --shadow-xl: 0 20px 50px rgba(0,0,0,0.4);
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: var(--font-primary);
            background-color: var(--color-background);
            color: var(--color-on-surface);
            line-height: 1.6;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            position: relative;
            overflow-x: hidden;
        }

        /* L3UI Light Reflection Effect */
        body::before {
            content: '';
            position: fixed;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle at 20% 20%, 
                rgba(255, 255, 255, 0.1) 0%, 
                transparent 60%);
            pointer-events: none;
            z-index: -1;
            opacity: 0;
            transition: opacity var(--transition-normal) ease;
        }

        [data-theme="light"] body::before {
            opacity: 1;
        }
        
        /* Layout */
        .container {
            width: 100%;
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 var(--space-md);
        }
        
        /* Typography */
        h1, h2, h3, h4, h5, h6 {
            font-family: var(--font-secondary);
            font-weight: 600;
            line-height: 1.2;
            margin-bottom: var(--space-sm);
        }
        
        h1 {
            font-size: var(--text-3xl);
        }
        
        h2 {
            font-size: var(--text-2xl);
        }
        
        h3 {
            font-size: var(--text-xl);
        }
        
        p {
            margin-bottom: var(--space-md);
        }
        
        /* Buttons */
        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: var(--space-sm) var(--space-md);
            border-radius: var(--radius-sm);
            font-family: var(--font-secondary);
            font-weight: 500;
            font-size: var(--text-sm);
            line-height: 1;
            text-decoration: none;
            cursor: pointer;
            transition: all var(--transition-fast) ease;
            border: none;
            outline: none;
            user-select: none;
            white-space: nowrap;
            gap: var(--space-xs);
            position: relative;
            overflow: hidden;
        }

        /* L3UI Button Effect */
        .btn::after {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle at center, 
                rgba(255, 255, 255, 0.3) 0%, 
                transparent 70%);
            transform: scale(0);
            transition: transform var(--transition-fast) ease;
            pointer-events: none;
        }

        .btn:hover::after {
            transform: scale(1);
        }
        
        .btn-primary {
            background-color: var(--color-primary);
            color: var(--color-on-primary);
        }
        
        .btn-primary:hover {
            background-color: var(--color-primary-dark);
            transform: translateY(-1px);
            box-shadow: var(--shadow-sm);
        }
        
        .btn-secondary {
            background-color: var(--color-secondary);
            color: var(--color-on-primary);
        }
        
        .btn-secondary:hover {
            opacity: 0.9;
            transform: translateY(-1px);
            box-shadow: var(--shadow-sm);
        }
        
        .btn-outline {
            background-color: transparent;
            color: var(--color-primary);
            border: 1px solid var(--color-primary);
        }
        
        .btn-outline:hover {
            background-color: rgba(var(--color-primary), 0.1);
        }
        
        .btn-icon {
            padding: var(--space-sm);
            border-radius: 50%;
        }
        
        /* Cards */
        .card {
            background-color: var(--color-surface);
            border-radius: var(--radius-md);
            box-shadow: var(--shadow-md);
            overflow: hidden;
            transition: all var(--transition-normal) ease;
            margin-bottom: var(--space-lg);
            border: 1px solid var(--color-border);
            position: relative;
            overflow: hidden;
        }

        /* L3UI Card Effect */
        .card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, 
                transparent, 
                rgba(255, 255, 255, 0.4), 
                transparent);
            opacity: 0;
            transition: opacity var(--transition-normal) ease;
        }

        [data-theme="light"] .card::before {
            opacity: 1;
        }
        
        .card:hover {
            box-shadow: var(--shadow-lg);
            transform: translateY(-2px);
        }
        
        .card-header {
            padding: var(--space-md);
            border-bottom: 1px solid var(--color-border);
        }
        
        .card-body {
            padding: var(--space-md);
        }
        
        .card-footer {
            padding: var(--space-md);
            border-top: 1px solid var(--color-border);
            display: flex;
            gap: var(--space-sm);
        }
        
        /* Forms */
        .form-group {
            margin-bottom: var(--space-md);
        }
        
        .form-label {
            display: block;
            margin-bottom: var(--space-xs);
            font-size: var(--text-sm);
            font-weight: 500;
            color: var(--color-on-surface);
        }
        
        .form-control {
            width: 100%;
            padding: var(--space-sm) var(--space-md);
            border: 1px solid var(--color-border);
            border-radius: var(--radius-sm);
            font-family: var(--font-primary);
            font-size: var(--text-base);
            background-color: var(--color-surface);
            color: var(--color-on-surface);
            transition: all var(--transition-fast);
            box-shadow: inset 0 1px 2px rgba(0,0,0,0.05);
        }

        .form-control:focus {
            outline: none;
            border-color: var(--color-primary);
            box-shadow: 0 0 0 2px rgba(var(--color-primary), 0.2), 
                        inset 0 1px 2px rgba(0,0,0,0.05);
        }
        
        textarea.form-control {
            min-height: 120px;
            resize: vertical;
        }
        
        /* Navigation */
        .navbar {
            background-color: var(--color-surface);
            box-shadow: var(--shadow-sm);
            padding: var(--space-sm) 0;
            position: sticky;
            top: 0;
            z-index: 100;
            border-bottom: 1px solid var(--color-border);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
        }
        
        .navbar-container {
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .navbar-brand {
            font-family: var(--font-secondary);
            font-weight: 700;
            font-size: var(--text-xl);
            color: var(--color-primary);
            text-decoration: none;
            display: flex;
            align-items: center;
            gap: var(--space-sm);
        }
        
        .navbar-actions {
            display: flex;
            align-items: center;
            gap: var(--space-sm);
        }
        
        /* Debate Chat */
        .chat-container {
            display: flex;
            flex-direction: column;
            height: 500px;
            overflow: hidden;
            position: relative;
        }
        
        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: var(--space-md);
            display: flex;
            flex-direction: column;
            gap: var(--space-md);
            scroll-behavior: smooth;
        }
        
        .message {
            max-width: 80%;
            padding: var(--space-sm) var(--space-md);
            border-radius: var(--radius-md);
            animation: fadeIn 0.3s ease;
            position: relative;
            line-height: 1.5;
            transition: all var(--transition-fast);
        }

        .message::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, 
                transparent, 
                rgba(255, 255, 255, 0.3), 
                transparent);
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .message-user {
            align-self: flex-end;
            background-color: var(--color-primary);
            color: var(--color-on-primary);
            border-bottom-right-radius: var(--radius-xs);
            box-shadow: var(--shadow-sm);
        }
        
        .message-ai {
            align-self: flex-start;
            background-color: var(--color-surface);
            border: 1px solid var(--color-border);
            border-bottom-left-radius: var(--radius-xs);
            box-shadow: var(--shadow-sm);
        }
        
        .message-system {
            align-self: center;
            background-color: var(--color-background);
            border: 1px solid var(--color-border);
            padding: var(--space-xs) var(--space-sm);
            font-size: var(--text-xs);
            color: var(--color-on-surface);
            opacity: 0.7;
            border-radius: var(--radius-lg);
        }

        .message-typing {
            display: flex;
            gap: var(--space-xs);
            padding: var(--space-sm) var(--space-md);
            align-items: center;
        }

        .typing-indicator {
            display: flex;
            gap: 4px;
        }

        .typing-dot {
            width: 8px;
            height: 8px;
            background-color: var(--color-on-surface);
            border-radius: 50%;
            opacity: 0.4;
            animation: typingAnimation 1.4s infinite ease-in-out;
        }

        .typing-dot:nth-child(1) {
            animation-delay: 0s;
        }

        .typing-dot:nth-child(2) {
            animation-delay: 0.2s;
        }

        .typing-dot:nth-child(3) {
            animation-delay: 0.4s;
        }

        @keyframes typingAnimation {
            0%, 60%, 100% { transform: translateY(0); opacity: 0.4; }
            30% { transform: translateY(-5px); opacity: 1; }
        }
        
        .chat-input {
            display: flex;
            gap: var(--space-sm);
            padding: var(--space-md);
            border-top: 1px solid var(--color-border);
            background-color: var(--color-surface);
            position: relative;
        }

        .chat-input::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, 
                transparent, 
                rgba(255, 255, 255, 0.3), 
                transparent);
        }
        
        /* Skeleton Loading */
        .skeleton {
            background-color: var(--color-border);
            border-radius: var(--radius-sm);
            position: relative;
            overflow: hidden;
        }
        
        .skeleton::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(
                90deg,
                transparent,
                rgba(255, 255, 255, 0.1),
                transparent
            );
            animation: shimmer 1.5s infinite;
        }
        
        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }
        
        .skeleton-text {
            height: 1em;
            margin-bottom: var(--space-xs);
            border-radius: var(--radius-sm);
        }
        
        .skeleton-text:last-child {
            margin-bottom: 0;
            width: 80%;
        }

        /* Enhanced Skeleton for AI Response */
        .skeleton-ai-response {
            display: flex;
            flex-direction: column;
            gap: var(--space-sm);
            width: 100%;
        }

        .skeleton-ai-line {
            height: 1em;
            border-radius: var(--radius-sm);
            background-color: var(--color-border);
            position: relative;
            overflow: hidden;
        }

        .skeleton-ai-line::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(
                90deg,
                transparent,
                rgba(255, 255, 255, 0.1),
                transparent
            );
            animation: shimmer 1.5s infinite;
        }

        .skeleton-ai-line.short {
            width: 90%;
        }

        .skeleton-ai-line.medium {
            width: 95%;
        }

        .skeleton-ai-line.long {
            width: 100%;
        }
        
        /* Debate History */
        .history-list {
            display: flex;
            flex-direction: column;
            gap: var(--space-sm);
        }
        
        .history-item {
            padding: var(--space-sm) var(--space-md);
            border-radius: var(--radius-sm);
            background-color: var(--color-surface);
            border: 1px solid var(--color-border);
            cursor: pointer;
            transition: all var(--transition-fast);
            position: relative;
            overflow: hidden;
        }

        .history-item::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, 
                transparent, 
                rgba(255, 255, 255, 0.2), 
                transparent);
        }
        
        .history-item:hover {
            background-color: var(--color-background);
            transform: translateX(2px);
            box-shadow: var(--shadow-sm);
        }
        
        .history-item-title {
            font-weight: 500;
            margin-bottom: var(--space-xs);
            display: -webkit-box;
            -webkit-line-clamp: 1;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }
        
        .history-item-preview {
            font-size: var(--text-sm);
            color: var(--color-on-surface);
            opacity: 0.7;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }
        
        /* Tabs */
        .tabs {
            display: flex;
            border-bottom: 1px solid var(--color-border);
            margin-bottom: var(--space-md);
            position: relative;
        }

        .tabs::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, 
                transparent, 
                rgba(255, 255, 255, 0.2), 
                transparent);
        }
        
        .tab {
            padding: var(--space-sm) var(--space-md);
            cursor: pointer;
            font-weight: 500;
            color: var(--color-on-surface);
            opacity: 0.7;
            border-bottom: 2px solid transparent;
            transition: all var(--transition-fast);
            position: relative;
        }
        
        .tab.active {
            opacity: 1;
            color: var(--color-primary);
            border-bottom-color: var(--color-primary);
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
            animation: fadeIn var(--transition-normal) ease;
        }
        
        /* Utility Classes */
        .hidden {
            display: none !important;
        }
        
        .mt-1 { margin-top: var(--space-xs); }
        .mt-2 { margin-top: var(--space-sm); }
        .mt-3 { margin-top: var(--space-md); }
        .mt-4 { margin-top: var(--space-lg); }
        .mt-5 { margin-top: var(--space-xl); }
        
        .mb-1 { margin-bottom: var(--space-xs); }
        .mb-2 { margin-bottom: var(--space-sm); }
        .mb-3 { margin-bottom: var(--space-md); }
        .mb-4 { margin-bottom: var(--space-lg); }
        .mb-5 { margin-bottom: var(--space-xl); }
        
        .text-center { text-align: center; }
        .text-muted { opacity: 0.7; }
        
        /* Animations */
        .animate-pulse {
            animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Floating Action Button */
        .fab {
            position: fixed;
            bottom: var(--space-lg);
            right: var(--space-lg);
            width: 56px;
            height: 56px;
            border-radius: 50%;
            background-color: var(--color-primary);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: var(--shadow-lg);
            cursor: pointer;
            z-index: 50;
            transition: all var(--transition-normal) ease;
        }

        .fab:hover {
            transform: translateY(-3px) scale(1.05);
            box-shadow: var(--shadow-xl);
        }

        .fab:active {
            transform: translateY(1px);
        }

        /* Responsive */
        @media (max-width: 768px) {
            .container {
                padding: 0 var(--space-sm);
            }
            
            .chat-container {
                height: 400px;
            }
            
            .message {
                max-width: 90%;
            }

            .fab {
                bottom: var(--space-md);
                right: var(--space-md);
            }
        }
    </style>
</head>
<body>
    <!-- Navigation -->
    <nav class="navbar">
        <div class="container navbar-container">
            <a href="#" class="navbar-brand">
                <span class="material-icons-round">forum</span>
                AI Rival Pro
            </a>
            <div class="navbar-actions">
                <button id="themeToggle" class="btn btn-icon">
                    <span class="material-icons-round">brightness_medium</span>
                </button>
                <button id="settingsToggle" class="btn btn-icon">
                    <span class="material-icons-round">settings</span>
                </button>
            </div>
        </div>
    </nav>

    <!-- Main Content -->
    <main class="container">
        <div class="mt-4">
            <h1>Intellectual Debate Platform</h1>
            <p class="text-muted">Challenge your ideas with an AI that thinks differently</p>
        </div>

        <!-- Tabs -->
        <div class="tabs mt-4">
            <div class="tab active" data-tab="debate">New Debate</div>
            <div class="tab" data-tab="history">History</div>
            <div class="tab" data-tab="settings">Settings</div>
        </div>

        <!-- Tab Contents -->
        <div class="tab-content active" id="debate-tab">
            <div class="card">
                <div class="card-header">
                    <h2>Start a Debate</h2>
                    <p class="text-muted">Present your argument and the AI will challenge it</p>
                </div>
                <div class="card-body">
                    <div class="form-group">
                        <label for="debateTopic" class="form-label">Topic/Position</label>
                        <input type="text" id="debateTopic" class="form-control" placeholder="Briefly state your position...">
                    </div>
                    <div class="form-group">
                        <label for="debateArgument" class="form-label">Your Argument</label>
                        <textarea id="debateArgument" class="form-control" placeholder="Present your case in detail..."></textarea>
                    </div>
                </div>
                <div class="card-footer">
                    <button id="startDebateBtn" class="btn btn-primary">
                        <span class="material-icons-round">forum</span>
                        Start Debate
                    </button>
                    <button id="clearDebateBtn" class="btn btn-outline">
                        <span class="material-icons-round">clear</span>
                        Clear
                    </button>
                </div>
            </div>

            <!-- Debate Chat -->
            <div id="debateChatContainer" class="card hidden">
                <div class="card-header">
                    <h2>Live Debate</h2>
                    <p class="text-muted">Engage with your AI opponent</p>
                </div>
                <div class="card-body" style="padding: 0;">
                    <div class="chat-container">
                        <div class="chat-messages" id="chatMessages">
                            <!-- Messages will be added here dynamically -->
                        </div>
                        <div class="chat-input">
                            <input type="text" id="chatInput" class="form-control" placeholder="Type your response..." style="flex: 1;">
                            <button id="sendMessageBtn" class="btn btn-primary">
                                <span class="material-icons-round">send</span>
                            </button>
                        </div>
                    </div>
                </div>
                <div class="card-footer">
                    <button id="endDebateBtn" class="btn btn-secondary">
                        <span class="material-icons-round">flag</span>
                        End Debate
                    </button>
                    <button id="saveDebateBtn" class="btn btn-outline">
                        <span class="material-icons-round">save</span>
                        Save
                    </button>
                </div>
            </div>
        </div>

        <!-- History Tab -->
        <div class="tab-content" id="history-tab">
            <div class="card">
                <div class="card-header">
                    <h2>Past Debates</h2>
                    <p class="text-muted">Review your intellectual exchanges</p>
                </div>
                <div class="card-body">
                    <div class="history-list" id="debateHistory">
                        <!-- History items will be added here dynamically -->
                        <div class="text-center text-muted mt-4 animate-pulse" id="loadingHistory">
                            Loading your debate history...
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Settings Tab -->
        <div class="tab-content" id="settings-tab">
            <div class="card">
                <div class="card-header">
                    <h2>Settings</h2>
                    <p class="text-muted">Customize your debate experience</p>
                </div>
                <div class="card-body">
                    <div class="form-group">
                        <label for="aiPersonality" class="form-label">AI Debate Style</label>
                        <select id="aiPersonality" class="form-control">
                            <option value="neutral">Neutral Examiner</option>
                            <option value="socratic">Socratic Questioner</option>
                            <option value="devil">Devil's Advocate</option>
                            <option value="scholar">Academic Scholar</option>
                            <option value="passionate">Passionate Opponent</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="aiIntensity" class="form-label">Debate Intensity</label>
                        <input type="range" id="aiIntensity" class="form-control" min="1" max="5" value="3">
                        <div class="flex justify-between mt-1">
                            <span>Gentle</span>
                            <span>Balanced</span>
                            <span>Intense</span>
                        </div>
                    </div>
                    <div class="form-group">
                        <label for="userDebateStyle" class="form-label">Your Preferred Style</label>
                        <select id="userDebateStyle" class="form-control">
                            <option value="logical">Logical/Formal</option>
                            <option value="casual">Casual/Conversational</option>
                            <option value="academic">Academic</option>
                            <option value="creative">Creative/Abstract</option>
                        </select>
                    </div>
                </div>
                <div class="card-footer">
                    <button id="saveSettingsBtn" class="btn btn-primary">
                        <span class="material-icons-round">save</span>
                        Save Settings
                    </button>
                </div>
            </div>
        </div>
    </main>

    <!-- Floating Action Button -->
    <div class="fab" id="newDebateFab" title="Start New Debate">
        <span class="material-icons-round">add</span>
    </div>

    <script>
        // ===== Global Variables =====
        const DEBATES_KEY = "ai_rival_debates";
        const SETTINGS_KEY = "ai_rival_settings";
        let debates = JSON.parse(localStorage.getItem(DEBATES_KEY)) || [];
        let settings = JSON.parse(localStorage.getItem(SETTINGS_KEY)) || {
            aiPersonality: "neutral",
            aiIntensity: 3,
            userDebateStyle: "logical",
            theme: "light"
        };
        let currentDebate = null;
        let useModel = null;
        let debateState = {
            topic: "",
            argument: "",
            messages: [],
            context: [],
            lastUserPosition: "",
            embeddings: null
        };
        let typingTimeout = null;

        // ===== DOM Elements =====
        const elements = {
            // Tabs
            tabs: document.querySelectorAll(".tab"),
            tabContents: document.querySelectorAll(".tab-content"),
            
            // Debate Form
            debateTopic: document.getElementById("debateTopic"),
            debateArgument: document.getElementById("debateArgument"),
            startDebateBtn: document.getElementById("startDebateBtn"),
            clearDebateBtn: document.getElementById("clearDebateBtn"),
            
            // Debate Chat
            debateChatContainer: document.getElementById("debateChatContainer"),
            chatMessages: document.getElementById("chatMessages"),
            chatInput: document.getElementById("chatInput"),
            sendMessageBtn: document.getElementById("sendMessageBtn"),
            endDebateBtn: document.getElementById("endDebateBtn"),
            saveDebateBtn: document.getElementById("saveDebateBtn"),
            
            // History
            debateHistory: document.getElementById("debateHistory"),
            loadingHistory: document.getElementById("loadingHistory"),
            
            // Settings
            aiPersonality: document.getElementById("aiPersonality"),
            aiIntensity: document.getElementById("aiIntensity"),
            userDebateStyle: document.getElementById("userDebateStyle"),
            saveSettingsBtn: document.getElementById("saveSettingsBtn"),
            
            // Theme
            themeToggle: document.getElementById("themeToggle"),
            settingsToggle: document.getElementById("settingsToggle"),
            
            // FAB
            newDebateFab: document.getElementById("newDebateFab")
        };

        // ===== Initialize App =====
        document.addEventListener("DOMContentLoaded", async () => {
            // Load settings
            loadSettings();
            
            // Load TensorFlow model
            await loadModel();
            
            // Set up event listeners
            setupEventListeners();
            
            // Load debate history
            loadDebateHistory();
        });

        // ===== TensorFlow Model =====
        async function loadModel() {
            try {
                console.log("Loading TensorFlow model...");
                useModel = await use.load();
                console.log("Model loaded successfully");
            } catch (error) {
                console.error("Failed to load model:", error);
                showError("Failed to initialize AI capabilities. Some features may not work offline.");
            }
        }

        // ===== Event Listeners =====
        function setupEventListeners() {
            // Tab navigation
            elements.tabs.forEach(tab => {
                tab.addEventListener("click", () => {
                    const tabId = tab.getAttribute("data-tab");
                    switchTab(tabId);
                });
            });
            
            // Debate form
            elements.startDebateBtn.addEventListener("click", startDebate);
            elements.clearDebateBtn.addEventListener("click", clearDebateForm);
            elements.newDebateFab.addEventListener("click", () => {
                switchTab("debate");
                elements.debateTopic.focus();
            });
            
            // Chat interface
            elements.sendMessageBtn.addEventListener("click", sendMessage);
            elements.chatInput.addEventListener("keypress", (e) => {
                if (e.key === "Enter") sendMessage();
            });
            elements.endDebateBtn.addEventListener("click", endDebate);
            elements.saveDebateBtn.addEventListener("click", saveDebate);
            
            // Settings
            elements.saveSettingsBtn.addEventListener("click", saveSettings);
            
            // Theme toggle
            elements.themeToggle.addEventListener("click", toggleTheme);
            
            // Settings toggle
            elements.settingsToggle.addEventListener("click", () => {
                switchTab("settings");
            });
        }

        // ===== Tab Navigation =====
        function switchTab(tabId) {
            // Update active tab
            elements.tabs.forEach(tab => {
                if (tab.getAttribute("data-tab") === tabId) {
                    tab.classList.add("active");
                } else {
                    tab.classList.remove("active");
                }
            });
            
            // Update active content
            elements.tabContents.forEach(content => {
                if (content.id === `${tabId}-tab`) {
                    content.classList.add("active");
                } else {
                    content.classList.remove("active");
                }
            });
            
            // Special handling for history tab
            if (tabId === "history") {
                loadDebateHistory();
            }

            // Hide FAB on debate tab
            if (tabId === "debate") {
                elements.newDebateFab.style.display = "none";
            } else {
                elements.newDebateFab.style.display = "flex";
            }
        }

        // ===== Debate Functions =====
        async function startDebate() {
            const topic = elements.debateTopic.value.trim();
            const argument = elements.debateArgument.value.trim();
            
            if (!topic || !argument) {
                showError("Please provide both a topic and your argument");
                return;
            }
            
            // Initialize debate state
            debateState = {
                topic,
                argument,
                messages: [],
                context: [],
                lastUserPosition: argument,
                embeddings: null
            };
            
            // Add user's initial argument to messages
            addMessage("user", `Topic: ${topic}\n\nMy Position: ${argument}`);
            
            // Show chat interface
            elements.debateChatContainer.classList.remove("hidden");
            
            // Scroll to chat
            elements.debateChatContainer.scrollIntoView({ behavior: "smooth" });
            
            // Generate AI response with typing indicator
            await generateAIResponse("initial");
        }

        function clearDebateForm() {
            elements.debateTopic.value = "";
            elements.debateArgument.value = "";
        }

        function endDebate() {
            if (confirm("Are you sure you want to end this debate? You can save it to your history first.")) {
                addMessage("system", "Debate ended by user");
                elements.debateChatContainer.classList.add("hidden");
                clearDebateForm();
            }
        }

        function saveDebate() {
            if (debateState.messages.length === 0) {
                showError("No debate to save");
                return;
            }
            
            const debate = {
                id: Date.now(),
                date: new Date().toISOString(),
                topic: debateState.topic,
                messages: debateState.messages
            };
            
            debates.unshift(debate);
            localStorage.setItem(DEBATES_KEY, JSON.stringify(debates));
            
            showSuccess("Debate saved to history");
            loadDebateHistory();
        }

        function sendMessage() {
            const message = elements.chatInput.value.trim();
            if (!message) return;
            
            // Add user message
            addMessage("user", message);
            debateState.lastUserPosition = message;
            
            // Clear input
            elements.chatInput.value = "";
            
            // Generate AI response with typing indicator
            generateAIResponse("response");
        }

        function addMessage(sender, text) {
            const message = {
                sender,
                text,
                timestamp: new Date().toISOString()
            };
            
            debateState.messages.push(message);
            
            // Add to UI
            const messageElement = document.createElement("div");
            messageElement.classList.add("message", `message-${sender}`);
            
            if (sender === "system") {
                messageElement.innerHTML = `<small>${text}</small>`;
            } else if (sender === "typing") {
                messageElement.classList.add("message-typing");
                messageElement.innerHTML = `
                    <div class="typing-indicator">
                        <div class="typing-dot"></div>
                        <div class="typing-dot"></div>
                        <div class="typing-dot"></div>
                    </div>
                    <small>AI is thinking...</small>
                `;
            } else {
                messageElement.textContent = text;
            }
            
            elements.chatMessages.appendChild(messageElement);
            
            // Scroll to bottom
            elements.chatMessages.scrollTop = elements.chatMessages.scrollHeight;
            
            return message;
        }

        // ===== AI Response Generation =====
        async function generateAIResponse(type) {
            // Show typing indicator
            const typingMessage = addMessage("typing", "");
            
            // Clear any previous timeout
            if (typingTimeout) {
                clearTimeout(typingTimeout);
            }
            
            // Generate response after a realistic delay (1-3 seconds)
            const delay = 1000 + Math.random() * 2000;
            
            typingTimeout = setTimeout(async () => {
                try {
                    // Remove typing indicator
                    elements.chatMessages.removeChild(elements.chatMessages.lastChild);
                    
                    // Generate response based on type
                    let response;
                    if (type === "initial") {
                        response = await generateInitialResponse();
                    } else {
                        response = await generateFollowUpResponse();
                    }
                    
                    // Add AI message
                    addMessage("ai", response);
                    
                    // Add to debate state
                    const aiMessage = {
                        sender: "ai",
                        text: response,
                        timestamp: new Date().toISOString()
                    };
                    debateState.messages.push(aiMessage);
                    
                } catch (error) {
                    console.error("Error generating AI response:", error);
                    addMessage("ai", "I encountered an error processing your argument. Please try again.");
                }
            }, delay);
        }

        async function generateInitialResponse() {
            const { topic, argument } = debateState;
            const personality = settings.aiPersonality;
            const intensity = settings.aiIntensity;
            
            try {
                // Generate embeddings for the argument
                debateState.embeddings = await useModel.embed([argument]);
                
                // Analyze the argument using TensorFlow
                const analysis = await analyzeArgument(argument, debateState.embeddings);
                
                // Generate a strategic response based on the analysis
                return generateStrategicResponse(topic, argument, analysis, personality, intensity);
            } catch (error) {
                console.error("Error in initial response generation:", error);
                return generateFallbackResponse(topic, argument, personality, intensity);
            }
        }

        async function generateFollowUpResponse() {
            const { topic, lastUserPosition, messages } = debateState;
            const personality = settings.aiPersonality;
            const intensity = settings.aiIntensity;
            
            try {
                // Generate embeddings for the latest message
                const embeddings = await useModel.embed([lastUserPosition]);
                
                // Analyze the conversation context
                const contextAnalysis = await analyzeConversationContext(messages, embeddings);
                
                // Generate a strategic follow-up
                return generateStrategicResponse(topic, lastUserPosition, contextAnalysis, personality, intensity);
            } catch (error) {
                console.error("Error in follow-up generation:", error);
                return generateFallbackResponse(topic, lastUserPosition, personality, intensity);
            }
        }

        async function analyzeArgument(text, embeddings) {
            // Perform various analyses using TensorFlow
            const results = {};
            
            // Sentiment analysis (simple approach)
            results.sentiment = tf.tidy(() => {
                const x = embeddings.slice([0, 0], [1, 512]);
                const dense = tf.layers.dense({ units: 1, activation: 'sigmoid' }).apply(x);
                return dense.dataSync()[0];
            });
            
            // Key concept extraction (simple frequency-based approach)
            results.keyConcepts = extractKeyConcepts(text);
            
            // Argument strength estimation
            results.strength = estimateArgumentStrength(text);
            
            // Logical consistency
            results.consistency = estimateLogicalConsistency(text);
            
            return results;
        }

        async function analyzeConversationContext(messages, latestEmbeddings) {
            // Analyze the flow of the conversation
            const results = {};
            
            // Get all user messages
            const userMessages = messages.filter(m => m.sender === "user");
            
            // Calculate similarity with previous messages
            if (userMessages.length > 1) {
                const previousText = userMessages[userMessages.length - 2].text;
                const previousEmbeddings = await useModel.embed([previousText]);
                
                results.similarity = tf.tidy(() => {
                    const a = latestEmbeddings;
                    const b = previousEmbeddings;
                    const similarity = tf.matMul(a, b, false, true).dataSync()[0];
                    return similarity;
                });
            } else {
                results.similarity = 0;
            }
            
            // Detect topic drift
            const initialText = userMessages[0].text;
            const initialEmbeddings = await useModel.embed([initialText]);
            
            results.topicDrift = tf.tidy(() => {
                const a = latestEmbeddings;
                const b = initialEmbeddings;
                const similarity = tf.matMul(a, b, false, true).dataSync()[0];
                return 1 - similarity; // Drift is inverse of similarity
            });
            
            return results;
        }

        function extractKeyConcepts(text) {
            // Simple implementation - in a real app, use proper NLP
            const words = text.toLowerCase().split(/\s+/);
            const stopWords = new Set(["the", "and", "but", "for", "with", "this", "that"]);
            const freq = {};
            
            words.forEach(word => {
                if (!stopWords.has(word) && word.length > 3) {
                    freq[word] = (freq[word] || 0) + 1;
                }
            });
            
            return Object.entries(freq)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 5)
                .map(([word]) => word);
        }

        function estimateArgumentStrength(text) {
            // Simple heuristic - count supporting evidence markers
            const evidenceMarkers = ["because", "since", "as shown by", "studies show", "research indicates"];
            let score = 0;
            
            evidenceMarkers.forEach(marker => {
                if (text.toLowerCase().includes(marker)) {
                    score += 1;
                }
            });
            
            // Normalize to 0-1 range
            return Math.min(1, score / 3);
        }

        function estimateLogicalConsistency(text) {
            // Simple heuristic - count logical connectors
            const connectors = ["therefore", "thus", "hence", "consequently", "however", "although"];
            let score = 0;
            
            connectors.forEach(connector => {
                if (text.toLowerCase().includes(connector)) {
                    score += 1;
                }
            });
            
            // Normalize to 0-1 range
            return Math.min(1, score / 4);
        }

        function generateStrategicResponse(topic, argument, analysis, personality, intensity) {
            // Enhanced response generation with dynamic structure
            const intensityLevel = Math.min(5, Math.max(1, intensity));
            
            // Response components
            const components = [];
            
            // 1. Introduction based on personality and sentiment
            components.push(generateIntroduction(topic, analysis.sentiment, personality));
            
            // 2. Key point recognition
            if (analysis.keyConcepts && analysis.keyConcepts.length > 0) {
                components.push(generateKeyPointRecognition(analysis.keyConcepts, personality));
            }
            
            // 3. Counterarguments based on intensity
            const counterpoints = generateCounterpoints(argument, analysis, intensityLevel);
            if (counterpoints.length > 0) {
                components.push(generateCounterargumentSection(counterpoints, personality));
            }
            
            // 4. Questions based on analysis
            components.push(generateQuestion(analysis, personality));
            
            // 5. Closing based on personality
            components.push(generateClosing(personality));
            
            // Combine components with appropriate spacing
            return components.filter(c => c).join("\n\n");
        }

        function generateIntroduction(topic, sentiment, personality) {
            const introductions = {
                neutral: [
                    `Let me examine your position on "${topic.substring(0, 50)}"...`,
                    `Your argument presents an interesting perspective on "${topic.substring(0, 50)}"...`,
                    `Regarding your position on "${topic.substring(0, 50)}", let's analyze it carefully...`
                ],
                socratic: [
                    `Let me ask you about your position on "${topic.substring(0, 50)}"...`,
                    `Your argument raises some important questions about "${topic.substring(0, 50)}"...`,
                    `I'd like to explore your thinking on "${topic.substring(0, 50)}" further...`
                ],
                devil: [
                    `I must challenge your position on "${topic.substring(0, 50)}"...`,
                    `Your argument about "${topic.substring(0, 50)}" seems problematic because...`,
                    `Let me play devil's advocate regarding "${topic.substring(0, 50)}"...`
                ],
                scholar: [
                    `Academic analysis of your position on "${topic.substring(0, 50)}" suggests...`,
                    `The scholarly consensus on "${topic.substring(0, 50)}" would question...`,
                    `From a research perspective, your view on "${topic.substring(0, 50)}"...`
                ],
                passionate: [
                    `I strongly disagree with your position on "${topic.substring(0, 50)}"!`,
                    `Your argument about "${topic.substring(0, 50)}" is deeply flawed because...`,
                    `I must passionately oppose your view on "${topic.substring(0, 50)}"...`
                ]
            };
            
            // Select based on personality
            const options = introductions[personality] || introductions.neutral;
            
            // Adjust based on sentiment
            if (sentiment > 0.7) {
                // Very positive - challenge optimism
                if (personality === "devil") {
                    return `Your overly optimistic view on "${topic.substring(0, 50)}" needs serious reconsideration...`;
                } else if (personality === "passionate") {
                    return `Your rose-colored glasses about "${topic.substring(0, 50)}" are blinding you to reality!`;
                }
            } else if (sentiment < 0.3) {
                // Very negative - challenge pessimism
                if (personality === "devil") {
                    return `Your pessimistic stance on "${topic.substring(0, 50)}" ignores important positive aspects...`;
                } else if (personality === "passionate") {
                    return `Your doom-and-gloom about "${topic.substring(0, 50)}" is completely exaggerated!`;
                }
            }
            
            return randomFromArray(options);
        }

        function generateKeyPointRecognition(keyConcepts, personality) {
            const recognitions = {
                neutral: `I notice you emphasize ${formatConcepts(keyConcepts)} in your argument.`,
                socratic: `You focus on ${formatConcepts(keyConcepts)} - could you define these more precisely?`,
                devil: `Your emphasis on ${formatConcepts(keyConcepts)} conveniently ignores important factors!`,
                scholar: `The concepts ${formatConcepts(keyConcepts)} have been extensively studied in the literature.`,
                passionate: `You're obsessed with ${formatConcepts(keyConcepts)} while ignoring everything else!`
            };
            
            return recognitions[personality] || recognitions.neutral;
        }

        function formatConcepts(concepts) {
            if (concepts.length === 1) return concepts[0];
            if (concepts.length === 2) return `${concepts[0]} and ${concepts[1]}`;
            return `${concepts.slice(0, -1).join(', ')}, and ${concepts[concepts.length - 1]}`;
        }

        function generateCounterpoints(argument, analysis, intensity) {
            const counterpoints = [];
            const numPoints = Math.min(intensity, 3); // 1-3 counterpoints
            
            // Base counterpoints (would be enhanced with real NLP)
            const baseCounters = [
                "the potential for confirmation bias in this position",
                "historical examples that contradict this view",
                "alternative interpretations of the same evidence",
                "the risk of oversimplifying a complex issue",
                "competing priorities that might outweigh this consideration",
                "the possibility of unintended consequences",
                "ethical concerns raised by this position",
                "more recent evidence that challenges this perspective",
                "the diversity of opinions among experts on this matter",
                "the practical challenges of implementing this idea"
            ];
            
            // Select counterpoints based on intensity
            for (let i = 0; i < numPoints; i++) {
                const counter = baseCounters[Math.floor(Math.random() * baseCounters.length)];
                if (!counterpoints.includes(counter)) {
                    counterpoints.push(counter);
                }
            }
            
            // Adjust based on analysis
            if (analysis.sentiment > 0.7) {
                // Very positive - challenge optimism
                counterpoints.push("the risks being underestimated in this optimistic view");
            } else if (analysis.sentiment < 0.3) {
                // Very negative - challenge pessimism
                counterpoints.push("potential upsides being overlooked in this negative assessment");
            }
            
            if (analysis.strength < 0.3) {
                counterpoints.push("the lack of substantial evidence supporting this claim");
            }
            
            if (analysis.consistency < 0.4) {
                counterpoints.push("the logical inconsistencies in this line of reasoning");
            }
            
            return counterpoints.slice(0, numPoints); // Ensure we don't exceed max
        }

        function generateCounterargumentSection(counterpoints, personality) {
            const sectionHeaders = {
                neutral: "Several aspects deserve consideration:",
                socratic: "Important questions arise:",
                devil: "Serious flaws in this argument include:",
                scholar: "The research suggests alternative perspectives:",
                passionate: "This argument fails because:"
            };
            
            let section = sectionHeaders[personality] || sectionHeaders.neutral;
            
            counterpoints.forEach((point, i) => {
                section += `\n${i+1}. ${capitalizeFirstLetter(point)}`;
                
                // Add personality-specific emphasis
                if (personality === "devil") {
                    section += " - this is a critical oversight!";
                } else if (personality === "passionate") {
                    section += " - how can you ignore this?";
                } else if (personality === "scholar") {
                    section += " (see Smith et al., 2020)";
                }
            });
            
            return section;
        }

        function generateQuestion(analysis, personality) {
            const questions = {
                neutral: [
                    "What evidence most strongly supports your position?",
                    "How would you respond to these counterpoints?",
                    "Could there be exceptions to this view?"
                ],
                socratic: [
                    "What is the basis for that conclusion?",
                    "Could you define your terms more precisely?",
                    "What would change your mind about this?"
                ],
                devil: [
                    "How can you possibly ignore these issues?",
                    "Isn't it obvious that this position is flawed?",
                    "Don't you see the problem with this reasoning?"
                ],
                scholar: [
                    "How does this align with the existing research?",
                    "What methodology led you to this conclusion?",
                    "Have you accounted for the peer-reviewed findings?"
                ],
                passionate: [
                    "How can you sleep at night believing this?",
                    "Don't you care about these consequences?",
                    "What kind of person would maintain this view?"
                ]
            };
            
            // Select based on personality
            const options = questions[personality] || questions.neutral;
            
            // Adjust based on analysis
            if (analysis.similarity < 0.3 && analysis.topicDrift > 0.7) {
                return "We seem to be drifting from the original topic. Should we refocus?";
            }
            
            if (analysis.strength < 0.3) {
                return "What stronger evidence could you provide to support this claim?";
            }
            
            return randomFromArray(options);
        }

        function generateClosing(personality) {
            const closings = {
                neutral: "I look forward to your response on these points.",
                socratic: "Your answers to these questions would help clarify your position.",
                devil: "These points seem to undermine your argument completely.",
                scholar: "These academic perspectives merit serious consideration.",
                passionate: "I can't believe anyone would maintain this view!"
            };
            
            return closings[personality] || closings.neutral;
        }

        function generateFallbackResponse(topic, argument, personality, intensity) {
            // Simple fallback when ML features fail
            const personalities = {
                neutral: `Your perspective on "${topic.substring(0, 50)}" is interesting. Could you elaborate on "${argument.substring(0, 50)}"?`,
                socratic: `What do you mean exactly by "${argument.substring(0, 50)}" when discussing "${topic.substring(0, 50)}"?`,
                devil: `That's a questionable position on "${topic.substring(0, 50)}"! How do you justify "${argument.substring(0, 50)}"?`,
                scholar: `The academic literature might challenge your view that "${argument.substring(0, 50)}" regarding "${topic.substring(0, 50)}".`,
                passionate: `I strongly disagree with your take on "${topic.substring(0, 50)}"! "${argument.substring(0, 50)}" is completely wrong!`
            };
            
            return personalities[personality] || personalities.neutral;
        }

        // ===== Debate History =====
        function loadDebateHistory() {
            elements.debateHistory.innerHTML = "";
            
            if (debates.length === 0) {
                elements.loadingHistory.textContent = "No past debates found";
                return;
            }
            
            elements.loadingHistory.classList.add("hidden");
            
            debates.forEach(debate => {
                const debateItem = document.createElement("div");
                debateItem.classList.add("history-item");
                debateItem.innerHTML = `
                    <div class="history-item-title">${debate.topic}</div>
                    <div class="history-item-preview">${debate.messages[0].text.substring(0, 100)}...</div>
                    <small class="text-muted">${new Date(debate.date).toLocaleDateString()}</small>
                `;
                
                debateItem.addEventListener("click", () => {
                    viewDebate(debate.id);
                });
                
                elements.debateHistory.appendChild(debateItem);
            });
        }

        function viewDebate(debateId) {
            const debate = debates.find(d => d.id === debateId);
            if (!debate) return;
            
            // Set current debate
            currentDebate = debate;
            
            // Show debate in chat interface
            elements.debateTopic.value = debate.topic;
            elements.debateArgument.value = debate.messages.find(m => m.sender === "user")?.text || "";
            
            // Clear and populate chat
            elements.chatMessages.innerHTML = "";
            debate.messages.forEach(message => {
                addMessage(message.sender, message.text);
            });
            
            // Show chat
            elements.debateChatContainer.classList.remove("hidden");
            
            // Switch to debate tab
            switchTab("debate");
            
            // Scroll to chat
            elements.debateChatContainer.scrollIntoView({ behavior: "smooth" });
        }

        // ===== Settings =====
        function loadSettings() {
            // Apply saved settings
            if (settings.theme) {
                document.documentElement.setAttribute("data-theme", settings.theme);
            }
            
            if (settings.aiPersonality) {
                elements.aiPersonality.value = settings.aiPersonality;
            }
            
            if (settings.aiIntensity) {
                elements.aiIntensity.value = settings.aiIntensity;
            }
            
            if (settings.userDebateStyle) {
                elements.userDebateStyle.value = settings.userDebateStyle;
            }
        }

        function saveSettings() {
            settings = {
                aiPersonality: elements.aiPersonality.value,
                aiIntensity: parseInt(elements.aiIntensity.value),
                userDebateStyle: elements.userDebateStyle.value,
                theme: document.documentElement.getAttribute("data-theme") || "light"
            };
            
            localStorage.setItem(SETTINGS_KEY, JSON.stringify(settings));
            showSuccess("Settings saved successfully");
        }

        // ===== Theme Management =====
        function toggleTheme() {
            const currentTheme = document.documentElement.getAttribute("data-theme") || "light";
            const newTheme = currentTheme === "light" ? "dark" : "light";
            
            document.documentElement.setAttribute("data-theme", newTheme);
            settings.theme = newTheme;
            localStorage.setItem(SETTINGS_KEY, JSON.stringify(settings));
        }

        // ===== Utility Functions =====
        function randomFromArray(array) {
            return array[Math.floor(Math.random() * array.length)];
        }

        function capitalizeFirstLetter(string) {
            return string.charAt(0).toUpperCase() + string.slice(1);
        }

        function showError(message) {
            const toast = document.createElement("div");
            toast.textContent = message;
            toast.style.position = "fixed";
            toast.style.bottom = "20px";
            toast.style.right = "20px";
            toast.style.backgroundColor = "var(--color-error)";
            toast.style.color = "white";
            toast.style.padding = "var(--space-sm) var(--space-md)";
            toast.style.borderRadius = "var(--radius-sm)";
            toast.style.boxShadow = "var(--shadow-md)";
            toast.style.zIndex = "1000";
            toast.style.animation = "fadeIn 0.3s ease";
            
            document.body.appendChild(toast);
            
            setTimeout(() => {
                toast.style.animation = "fadeOut 0.3s ease";
                setTimeout(() => {
                    document.body.removeChild(toast);
                }, 300);
            }, 3000);
        }

        function showSuccess(message) {
            const toast = document.createElement("div");
            toast.textContent = message;
            toast.style.position = "fixed";
            toast.style.bottom = "20px";
            toast.style.right = "20px";
            toast.style.backgroundColor = "var(--color-success)";
            toast.style.color = "white";
            toast.style.padding = "var(--space-sm) var(--space-md)";
            toast.style.borderRadius = "var(--radius-sm)";
            toast.style.boxShadow = "var(--shadow-md)";
            toast.style.zIndex = "1000";
            toast.style.animation = "fadeIn 0.3s ease";
            
            document.body.appendChild(toast);
            
            setTimeout(() => {
                toast.style.animation = "fadeOut 0.3s ease";
                setTimeout(() => {
                    document.body.removeChild(toast);
                }, 300);
            }, 3000);
        }
    </script>
</body>
</html>