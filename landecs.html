<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Real-time flood monitoring and predictive analytics for the Philippines">
    <meta name="theme-color" content="#1976D2">
    <title>Agos PH â€¢ Real-Time Flood Monitoring</title>

    <!-- PWA Manifest -->
    <link rel="manifest" href="manifest.json">

    <!-- Favicon -->
    <link rel="icon" href="favicon.ico" type="image/x-icon">
    <link rel="apple-touch-icon" href="icons/icon-192x192.png">

    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">

    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />

    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

    <!-- Material Icons -->
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">

    <!-- Animate.css -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css">

    <style>
        :root {
            --primary-color: #1976D2;
            --primary-dark: #1565C0;
            --primary-light: #E3F2FD;
            --secondary-color: #FF9800;
            --danger-color: #F44336;
            --success-color: #4CAF50;
            --warning-color: #FFC107;
            --dark-bg: #121212;
            --dark-surface: #1E1E1E;
            --dark-text: #E0E0E0;
            --light-bg: #F5F5F5;
            --light-surface: #FFFFFF;
            --light-text: #212121;
            --shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            --transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Poppins', sans-serif;
        }

        body {
            background-color: var(--light-bg);
            color: var(--light-text);
            transition: var(--transition);
            min-height: 100vh;
        }

        body.dark-mode {
            background-color: var(--dark-bg);
            color: var(--dark-text);
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 15px;
        }

        header {
            background-color: var(--primary-color);
            color: white;
            padding: 15px 0;
            box-shadow: var(--shadow);
            position: relative;
            z-index: 1000;
            transition: var(--transition);
        }

        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .logo {
            font-weight: 700;
            font-size: 1.5rem;
            display: flex;
            align-items: center;
        }

        .logo i {
            margin-right: 10px;
        }

        .nav-controls {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .theme-toggle,
        .language-toggle {
            background: none;
            border: none;
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            font-size: 1rem;
            transition: var(--transition);
        }

        .theme-toggle:hover,
        .language-toggle:hover {
            opacity: 0.9;
            transform: translateY(-1px);
        }

        .theme-toggle i,
        .language-toggle i {
            margin-right: 5px;
        }

        main {
            padding: 20px 0;
            min-height: calc(100vh - 120px);
        }

        .map-container {
            height: 400px;
            margin-bottom: 20px;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: var(--shadow);
            position: relative;
            transition: var(--transition);
        }

        #flood-map {
            height: 100%;
            width: 100%;
        }

        .map-overlay {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 1000;
            background-color: rgba(255, 255, 255, 0.9);
            padding: 10px;
            border-radius: 5px;
            box-shadow: var(--shadow);
            max-width: 200px;
            transition: var(--transition);
        }

        body.dark-mode .map-overlay {
            background-color: rgba(30, 30, 30, 0.9);
        }

        .map-overlay h4 {
            margin-bottom: 5px;
            font-size: 0.9rem;
        }

        .legend {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            font-size: 0.8rem;
            transition: var(--transition);
        }

        .legend-color {
            width: 20px;
            height: 20px;
            margin-right: 8px;
            border-radius: 3px;
            transition: var(--transition);
        }

        .dashboard {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .card {
            background-color: var(--light-surface);
            border-radius: 8px;
            padding: 20px;
            box-shadow: var(--shadow);
            transition: var(--transition);
            animation: fadeIn 0.5s ease-out;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        body.dark-mode .card {
            background-color: var(--dark-surface);
        }

        .card:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
        }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
        }

        body.dark-mode .card-header {
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .card-title {
            font-weight: 600;
            font-size: 1.1rem;
        }

        .card-content {
            min-height: 150px;
        }

        .chart-container {
            position: relative;
            height: 200px;
            width: 100%;
        }

        .flood-prediction {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 15px;
        }

        .prediction-level {
            font-size: 1.5rem;
            font-weight: 700;
            margin: 10px 0;
            transition: var(--transition);
        }

        .low-risk {
            color: var(--success-color);
        }

        .moderate-risk {
            color: var(--warning-color);
        }

        .high-risk {
            color: var(--danger-color);
        }

        .prediction-time {
            font-size: 1.2rem;
            margin-bottom: 10px;
        }

        .sensor-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
        }

        .sensor-item {
            display: flex;
            align-items: center;
            transition: var(--transition);
        }

        .sensor-item:hover {
            transform: translateX(5px);
        }

        .sensor-icon {
            font-size: 2rem;
            margin-right: 10px;
            color: var(--primary-color);
            transition: var(--transition);
        }

        .sensor-info h4 {
            font-size: 0.9rem;
            margin-bottom: 5px;
        }

        .sensor-value {
            font-weight: 600;
            font-size: 1.1rem;
        }

        .road-alerts {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .road-alert {
            display: flex;
            align-items: center;
            padding: 10px;
            background-color: rgba(244, 67, 54, 0.1);
            border-radius: 5px;
            transition: var(--transition);
        }

        .road-alert:hover {
            background-color: rgba(244, 67, 54, 0.2);
        }

        .road-alert i {
            margin-right: 10px;
            color: var(--danger-color);
        }

        .road-name {
            font-weight: 500;
        }

        .road-status {
            font-size: 0.8rem;
            margin-top: 3px;
        }

        .search-container {
            margin-bottom: 20px;
        }

        .search-bar {
            display: flex;
            gap: 10px;
        }

        #location-search {
            flex: 1;
            padding: 12px 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 1rem;
            transition: var(--transition);
        }

        #location-search:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 2px rgba(25, 118, 210, 0.2);
        }

        body.dark-mode #location-search {
            background-color: var(--dark-surface);
            border-color: #444;
            color: var(--dark-text);
        }

        .search-btn {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 0 20px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: 500;
            transition: var(--transition);
        }

        .search-btn:hover {
            background-color: var(--primary-dark);
            transform: translateY(-1px);
        }

        .location-info {
            margin-top: 15px;
            padding: 15px;
            background-color: var(--primary-light);
            border-radius: 5px;
            display: none;
            animation: fadeIn 0.3s ease-out;
            transition: var(--transition);
        }

        body.dark-mode .location-info {
            background-color: rgba(25, 118, 210, 0.2);
        }

        .location-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
        }

        .location-title {
            font-weight: 600;
            font-size: 1.2rem;
        }

        .location-data {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
        }

        .data-item {
            display: flex;
            flex-direction: column;
        }

        .data-label {
            font-size: 0.8rem;
            opacity: 0.8;
        }

        .data-value {
            font-weight: 600;
            font-size: 1.1rem;
            margin-top: 5px;
        }

        footer {
            background-color: var(--primary-color);
            color: white;
            padding: 20px 0;
            text-align: center;
            font-size: 0.9rem;
            transition: var(--transition);
        }

        .footer-links {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 15px;
        }

        .footer-link {
            color: white;
            text-decoration: none;
            transition: var(--transition);
        }

        .footer-link:hover {
            text-decoration: underline;
            opacity: 0.9;
        }

        .last-updated {
            margin-top: 10px;
            font-size: 0.8rem;
            opacity: 0.8;
        }

        /* Loading spinner */
        .spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255, 255, 255, .3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        /* PWA install prompt */
        .install-prompt {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background-color: var(--light-surface);
            padding: 15px;
            border-radius: 8px;
            box-shadow: var(--shadow);
            display: none;
            z-index: 1000;
            max-width: 300px;
            animation: slideInUp 0.3s ease-out;
            transition: var(--transition);
        }

        body.dark-mode .install-prompt {
            background-color: var(--dark-surface);
        }

        .install-prompt p {
            margin-bottom: 10px;
        }

        .prompt-buttons {
            display: flex;
            gap: 10px;
        }

        .install-btn {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 5px;
            cursor: pointer;
            transition: var(--transition);
        }

        .install-btn:hover {
            background-color: var(--primary-dark);
        }

        .dismiss-btn {
            background: none;
            border: 1px solid #ddd;
            padding: 5px 10px;
            border-radius: 5px;
            cursor: pointer;
            transition: var(--transition);
        }

        .dismiss-btn:hover {
            background-color: rgba(0, 0, 0, 0.05);
        }

        body.dark-mode .dismiss-btn {
            border-color: #444;
        }

        body.dark-mode .dismiss-btn:hover {
            background-color: rgba(255, 255, 255, 0.05);
        }

        /* Notification permission prompt */
        .notification-prompt {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background-color: var(--light-surface);
            padding: 15px;
            border-radius: 8px;
            box-shadow: var(--shadow);
            display: none;
            z-index: 1000;
            max-width: 300px;
            animation: slideInUp 0.3s ease-out;
        }

        body.dark-mode .notification-prompt {
            background-color: var(--dark-surface);
        }

        /* Offline indicator */
        .offline-indicator {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: var(--danger-color);
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            box-shadow: var(--shadow);
            display: none;
            z-index: 1000;
            animation: slideInUp 0.3s ease-out;
        }

        /* Modal styles */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 2000;
            justify-content: center;
            align-items: center;
            animation: fadeIn 0.3s ease-out;
        }

        .modal-content {
            background-color: var(--light-surface);
            border-radius: 8px;
            width: 90%;
            max-width: 500px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: var(--shadow);
            animation: slideInUp 0.3s ease-out;
            transition: var(--transition);
        }

        body.dark-mode .modal-content {
            background-color: var(--dark-surface);
        }

        .modal-header {
            padding: 15px;
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        body.dark-mode .modal-header {
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .modal-body {
            padding: 15px;
        }

        .modal-footer {
            padding: 15px;
            border-top: 1px solid rgba(0, 0, 0, 0.1);
            display: flex;
            justify-content: flex-end;
        }

        body.dark-mode .modal-footer {
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .modal-btn {
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            transition: var(--transition);
        }

        .modal-btn-primary {
            background-color: var(--primary-color);
            color: white;
            border: none;
        }

        .modal-btn-primary:hover {
            background-color: var(--primary-dark);
        }

        .modal-close {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: var(--light-text);
            transition: var(--transition);
        }

        body.dark-mode .modal-close {
            color: var(--dark-text);
        }

        .modal-close:hover {
            color: var(--danger-color);
        }

        /* Bottom sheet */
        .bottom-sheet {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background-color: var(--light-surface);
            border-radius: 16px 16px 0 0;
            box-shadow: 0 -4px 12px rgba(0, 0, 0, 0.15);
            z-index: 1500;
            transform: translateY(100%);
            transition: transform 0.3s ease-out;
            max-height: 80vh;
            overflow-y: auto;
        }

        .bottom-sheet.active {
            transform: translateY(0);
        }

        .bottom-sheet-header {
            padding: 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
            position: sticky;
            top: 0;
            background-color: inherit;
            z-index: 1;
        }

        body.dark-mode .bottom-sheet-header {
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .bottom-sheet-body {
            padding: 16px;
        }

        .bottom-sheet-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 1499;
            display: none;
            animation: fadeIn 0.3s ease-out;
        }

        /* Loading overlay */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.7);
            display: none;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 3000;
            animation: fadeIn 0.3s ease-out;
        }

        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 5px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 1s ease-in-out infinite;
            margin-bottom: 20px;
        }

        .loading-overlay p {
            color: white;
            margin-top: 15px;
            font-size: 1.1rem;
        }

        /* Permission dialog */
        .permission-dialog {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: var(--light-surface);
            border-radius: 8px;
            padding: 20px;
            max-width: 90%;
            width: 400px;
            box-shadow: var(--shadow);
            z-index: 2000;
            display: none;
            animation: fadeIn 0.3s ease-out;
        }

        body.dark-mode .permission-dialog {
            background-color: var(--dark-surface);
        }

        .permission-dialog h3 {
            margin-bottom: 15px;
        }

        .permission-dialog p {
            margin-bottom: 20px;
            line-height: 1.5;
        }

        .permission-buttons {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }

        /* Tracking transparency dialog */
        .tracking-dialog {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: var(--light-surface);
            border-radius: 8px;
            padding: 20px;
            max-width: 90%;
            width: 400px;
            box-shadow: var(--shadow);
            z-index: 2000;
            display: none;
            animation: fadeIn 0.3s ease-out;
        }

        body.dark-mode .tracking-dialog {
            background-color: var(--dark-surface);
        }

        .tracking-dialog h3 {
            margin-bottom: 15px;
        }

        .tracking-dialog p {
            margin-bottom: 20px;
            line-height: 1.5;
        }

        .tracking-options {
            margin-bottom: 20px;
        }

        .tracking-option {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }

        .tracking-option input {
            margin-right: 10px;
        }

        .tracking-buttons {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .header-content {
                flex-direction: column;
                gap: 10px;
            }

            .dashboard {
                grid-template-columns: 1fr;
            }

            .sensor-grid {
                grid-template-columns: 1fr;
            }

            .map-overlay {
                max-width: 150px;
            }

            .modal-content {
                width: 95%;
            }
        }

        @media (max-width: 480px) {
            .footer-links {
                flex-wrap: wrap;
                gap: 10px;
            }

            .search-bar {
                flex-direction: column;
            }

            .search-btn {
                width: 100%;
                padding: 12px;
            }

            .location-data {
                grid-template-columns: 1fr 1fr;
            }
        }
    </style>
</head>

<body>
    <header>
        <div class="container header-content">
            <div class="logo">
                <i class="material-icons">water_damage</i>
                <span>Agos PH</span>
            </div>
            <div class="nav-controls">
                <button class="language-toggle" id="language-toggle" aria-label="Toggle language">
                    <i class="material-icons">translate</i>
                    <span>EN</span>
                </button>
                <button class="theme-toggle" id="theme-toggle" aria-label="Toggle theme">
                    <i class="material-icons">brightness_4</i>
                    <span>Dark</span>
                </button>
            </div>
        </div>
    </header>

    <main class="container">
        <div class="search-container">
            <div class="search-bar">
                <input type="text" id="location-search" placeholder="Search for barangay or city..." aria-label="Location search">
                <button class="search-btn" id="search-btn" aria-label="Search location">
                    <span id="search-text">Search</span>
                    <span id="search-spinner" class="spinner" style="display: none;" aria-hidden="true"></span>
                </button>
            </div>
            <div class="location-info" id="location-info" style="display: none;">
                <div class="location-header">
                    <div class="location-title" id="selected-location">Loading...</div>
                    <div class="last-updated" id="location-updated">Updated: -</div>
                </div>
                <div class="location-data">
                    <div class="data-item">
                        <span class="data-label">Current Risk</span>
                        <span class="data-value" id="current-risk">-</span>
                    </div>
                    <div class="data-item">
                        <span class="data-label">Rainfall</span>
                        <span class="data-value" id="rainfall-value">-</span>
                    </div>
                    <div class="data-item">
                        <span class="data-label">Water Level</span>
                        <span class="data-value" id="water-level">-</span>
                    </div>
                    <div class="data-item">
                        <span class="data-label">Flood Depth</span>
                        <span class="data-value" id="flood-depth">-</span>
                    </div>
                </div>
            </div>
        </div>

        <div class="map-container">
            <div id="flood-map"></div>
            <div class="map-overlay">
                <h4>Flood Risk Legend</h4>
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #4CAF50;"></div>
                        <span>Low Risk (0-30cm)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #FFC107;"></div>
                        <span>Moderate (30-60cm)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #F44336;"></div>
                        <span>High (60-100cm)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #9C27B0;"></div>
                        <span>Extreme (100cm+)</span>
                    </div>
                </div>
                <div class="map-controls">
                    <button id="locate-me" class="map-control-btn" aria-label="Locate me">
                        <i class="material-icons">my_location</i>
                    </button>
                    <button id="zoom-in" class="map-control-btn" aria-label="Zoom in">
                        <i class="material-icons">add</i>
                    </button>
                    <button id="zoom-out" class="map-control-btn" aria-label="Zoom out">
                        <i class="material-icons">remove</i>
                    </button>
                </div>
            </div>
        </div>

        <div class="dashboard">
            <div class="card emergency-card" id="emergency-card" style="display: none;">
                <div class="card-header">
                    <div class="card-title">Emergency Alert</div>
                    <i class="material-icons">warning</i>
                </div>
                <div class="card-content">
                    <div class="emergency-alert" id="emergency-alert-content">
                        <!-- Dynamically populated -->
                    </div>
                    <div class="emergency-actions">
                        <button class="emergency-btn" id="view-evac-routes">
                            <i class="material-icons">directions</i>
                            <span>Evacuation Routes</span>
                        </button>
                        <button class="emergency-btn" id="call-emergency">
                            <i class="material-icons">call</i>
                            <span>Emergency Contacts</span>
                        </button>
                    </div>
                </div>
            </div>

            <div class="card">
                <div class="card-header">
                    <div class="card-title">Flood Prediction</div>
                    <i class="material-icons">schedule</i>
                </div>
                <div class="card-content">
                    <div class="flood-prediction">
                        <div>Flood possible in</div>
                        <div class="prediction-time" id="prediction-time">-</div>
                        <div class="prediction-level" id="prediction-level">-</div>
                        <div id="prediction-details">Gathering data...</div>
                    </div>
                </div>
            </div>

            <div class="card">
                <div class="card-header">
                    <div class="card-title">Rainfall & Water Sensors</div>
                    <i class="material-icons">sensors</i>
                </div>
                <div class="card-content">
                    <div class="sensor-grid">
                        <div class="sensor-item">
                            <div class="sensor-icon">
                                <i class="material-icons">water_drop</i>
                            </div>
                            <div class="sensor-info">
                                <h4>Rain Rate</h4>
                                <div class="sensor-value" id="rain-rate">-</div>
                            </div>
                        </div>
                        <div class="sensor-item">
                            <div class="sensor-icon">
                                <i class="material-icons">trending_up</i>
                            </div>
                            <div class="sensor-info">
                                <h4>Rise Velocity</h4>
                                <div class="sensor-value" id="rise-velocity">-</div>
                            </div>
                        </div>
                        <div class="sensor-item">
                            <div class="sensor-icon">
                                <i class="material-icons">calendar_today</i>
                            </div>
                            <div class="sensor-info">
                                <h4>Last Heavy Rain</h4>
                                <div class="sensor-value" id="last-heavy-rain">-</div>
                            </div>
                        </div>
                        <div class="sensor-item">
                            <div class="sensor-icon">
                                <i class="material-icons">compare</i>
                            </div>
                            <div class="sensor-info">
                                <h4>vs. Average</h4>
                                <div class="sensor-value" id="vs-average">-</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="card">
                <div class="card-header">
                    <div class="card-title">7-Day Rainfall</div>
                    <i class="material-icons">bar_chart</i>
                </div>
                <div class="card-content">
                    <div class="chart-container">
                        <canvas id="rainfall-chart" aria-label="7-day rainfall chart" role="img"></canvas>
                    </div>
                </div>
            </div>

            <div class="card">
                <div class="card-header">
                    <div class="card-title">Flood-Impacted Roads</div>
                    <i class="material-icons">directions</i>
                </div>
                <div class="card-content">
                    <div class="road-alerts" id="road-alerts">
                        <div class="no-data">Loading road conditions...</div>
                    </div>
                </div>
            </div>

            <div class="card">
                <div class="card-header">
                    <div class="card-title">6-Hour Forecast</div>
                    <i class="material-icons">timeline</i>
                </div>
                <div class="card-content">
                    <div class="chart-container">
                        <canvas id="forecast-chart" aria-label="6-hour forecast chart" role="img"></canvas>
                    </div>
                </div>
            </div>

            <div class="card">
                <div class="card-header">
                    <div class="card-title">Flood Hotspots</div>
                    <i class="material-icons">location_on</i>
                </div>
                <div class="card-content">
                    <div id="hotspots-list">
                        <div class="no-data">Identifying flood hotspots...</div>
                    </div>
                </div>
            </div>

            <div class="card">
                <div class="card-header">
                    <div class="card-title">Nearby Evacuation Centers</div>
                    <i class="material-icons">place</i>
                </div>
                <div class="card-content">
                    <div id="evacuation-centers">
                        <div class="no-data">Loading evacuation centers...</div>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <footer>
        <div class="container">
            <div class="footer-links">
                <a href="/about" class="footer-link">About</a>
                <a href="/data-sources" class="footer-link">Data Sources</a>
                <a href="/emergency-contacts" class="footer-link">Emergency Contacts</a>
                <a href="/feedback" class="footer-link">Feedback</a>
                <a href="/privacy" class="footer-link">Privacy Policy</a>
            </div>
            <p>Agos PH: Real-Time Flood Monitoring System</p>
            <p class="last-updated" id="global-updated">Last updated: <span id="update-time">-</span></p>
            <p class="disclaimer">Data is provided by PAGASA, MMDA, and local government units. Use at your own risk.</p>
        </div>
    </footer>

    <!-- Install Prompt -->
    <div class="install-prompt" id="install-prompt" style="display: none;" role="dialog" aria-labelledby="install-prompt-title">
        <p id="install-prompt-title">Install Agos PH for faster access and offline use?</p>
        <div class="prompt-buttons">
            <button class="install-btn" id="install-btn">Install</button>
            <button class="dismiss-btn" id="dismiss-btn">Not Now</button>
        </div>
    </div>

    <!-- Notification Prompt -->
    <div class="notification-prompt" id="notification-prompt" style="display: none;" role="dialog" aria-labelledby="notification-prompt-title">
        <p id="notification-prompt-title">Get flood alerts for your area?</p>
        <div class="prompt-buttons">
            <button class="install-btn" id="enable-notifications">Enable</button>
            <button class="dismiss-btn" id="dismiss-notifications">Later</button>
        </div>
    </div>

    <!-- Offline Indicator -->
    <div class="offline-indicator" id="offline-indicator" style="display: none;" role="status">
        You are currently offline. Showing last available data.
    </div>

    <!-- Emergency Modal -->
    <div class="modal" id="emergency-modal" style="display: none;" role="dialog" aria-modal="true" aria-labelledby="emergency-modal-title">
        <div class="modal-content">
            <div class="modal-header">
                <h3 id="emergency-modal-title">Emergency Alert</h3>
                <button class="modal-close" id="emergency-modal-close" aria-label="Close">&times;</button>
            </div>
            <div class="modal-body" id="emergency-modal-body">
                <!-- Content will be inserted here -->
            </div>
            <div class="modal-footer">
                <button class="modal-btn modal-btn-primary" id="emergency-modal-confirm">Understood</button>
            </div>
        </div>
    </div>

    <!-- Loading Overlay -->
    <div class="loading-overlay" id="loading-overlay" style="display: none;">
        <div class="loading-spinner"></div>
        <p>Loading latest flood data...</p>
    </div>

    <!-- Bottom Sheet -->
    <div class="bottom-sheet" id="bottom-sheet">
        <div class="bottom-sheet-header">
            <h3 id="bottom-sheet-title">Details</h3>
            <button class="modal-close" id="bottom-sheet-close">&times;</button>
        </div>
        <div class="bottom-sheet-body" id="bottom-sheet-content">
            <!-- Content will be inserted here -->
        </div>
    </div>
    <div class="bottom-sheet-overlay" id="bottom-sheet-overlay"></div>

    <!-- Permission Dialog -->
    <div class="permission-dialog" id="location-permission-dialog" style="display: none;">
        <h3>Location Access Needed</h3>
        <p>Agos PH needs access to your location to provide accurate flood alerts and monitoring for your area. Your location data is only used to serve you better and is never shared with third parties.</p>
        <div class="permission-buttons">
            <button class="dismiss-btn" id="deny-location">Not Now</button>
            <button class="install-btn" id="grant-location">Allow Access</button>
        </div>
    </div>

    <!-- Tracking Transparency Dialog -->
    <div class="tracking-dialog" id="tracking-dialog" style="display: none;">
        <h3>Privacy Preferences</h3>
        <p>We respect your privacy. Please choose how you'd like us to handle your data:</p>
        <div class="tracking-options">
            <div class="tracking-option">
                <input type="radio" id="tracking-essential" name="tracking" value="essential" checked>
                <label for="tracking-essential">Essential Only (Required for app functionality)</label>
            </div>
            <div class="tracking-option">
                <input type="radio" id="tracking-analytics" name="tracking" value="analytics">
                <label for="tracking-analytics">Analytics (Help improve the app)</label>
            </div>
            <div class="tracking-option">
                <input type="radio" id="tracking-personalized" name="tracking" value="personalized">
                <label for="tracking-personalized">Personalized (Tailor experience to your needs)</label>
            </div>
        </div>
        <div class="tracking-buttons">
            <button class="dismiss-btn" id="tracking-cancel">Cancel</button>
            <button class="install-btn" id="tracking-confirm">Save Preferences</button>
        </div>
    </div>

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

    <!-- CSP Nonce for scripts -->
    <script nonce="YOUR_CSP_NONCE_VALUE">
        // API Configuration
        const API_CONFIG = {
            BASE_URL: 'https://api.agos.ph/v1',
            ENDPOINTS: {
                FLOOD_DATA: '/flood-data',
                RAINFALL: '/rainfall',
                PREDICTIONS: '/predictions',
                ROADS: '/affected-roads',
                EVACUATION: '/evacuation-centers',
                GEOLOCATION: '/geolocation',
                ALERTS: '/alerts',
                SENSORS: '/sensors'
            },
            API_KEY: '9b4314ca106bd5835f4d1953724cfe5b', // Replace with actual API key
            CACHE_TTL: 300000, // 5 minutes cache time
            MAX_RETRIES: 3,
            TIMEOUT: 10000 // 10 seconds
        };

        // Flood Risk Configuration
        const FLOOD_RISK_LEVELS = {
            LOW: {
                threshold: 30,
                color: '#4CAF50',
                label: 'Low Risk'
            },
            MODERATE: {
                threshold: 60,
                color: '#FFC107',
                label: 'Moderate Risk'
            },
            HIGH: {
                threshold: 100,
                color: '#F44336',
                label: 'High Risk'
            },
            EXTREME: {
                threshold: Infinity,
                color: '#9C27B0',
                label: 'Extreme Risk'
            }
        };

        // Map Configuration
        const MAP_CONFIG = {
            DEFAULT_CENTER: [12.8797, 121.7740], // Philippines coordinates
            DEFAULT_ZOOM: 6,
            MIN_ZOOM: 5,
            MAX_ZOOM: 18,
            TILE_LAYER: 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
            ATTRIBUTION: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
            FLOOD_LAYER_OPACITY: 0.6,
            FLOOD_LAYER_WEIGHT: 2,
            USER_MARKER_RADIUS: 8,
            USER_MARKER_COLOR: '#4285F4',
            EVAC_MARKER_ICON: 'place',
            EVAC_MARKER_COLOR: '#4CAF50'
        };

        // Application State
        const appState = {
            // Map components
            map: null,
            floodLayer: null,
            evacuationLayer: null,
            userMarker: null,
            
            // Data state
            floodData: null,
            rainfallData: null,
            predictions: null,
            affectedRoads: null,
            evacuationCenters: null,
            sensorData: null,
            
            // User state
            currentLocation: null,
            selectedLocation: null,
            
            // UI state
            lastUpdate: null,
            offlineMode: false,
            dataStatus: 'loading', // 'loading', 'live', 'cached', 'error'
            
            // User preferences
            preferences: {
                theme: localStorage.getItem('theme') || 'light',
                language: localStorage.getItem('language') || 'en',
                notifications: localStorage.getItem('notifications') || 'unset',
                tracking: localStorage.getItem('tracking') || 'essential',
                locationPermission: localStorage.getItem('locationPermission') || 'unset'
            },
            
            // Charts
            charts: {
                rainfallChart: null,
                forecastChart: null
            },
            
            // PWA state
            deferredPrompt: null,
            
            // Service worker registration
            serviceWorkerRegistration: null
        };

        // Initialize the application
        document.addEventListener('DOMContentLoaded', async function() {
            try {
                // Initialize UI components first
                initTheme();
                initMap();
                initCharts();
                initEventListeners();
                
                // Register service worker
                await initServiceWorker();
                
                // Check connectivity
                checkConnectivity();
                
                // Show tracking dialog if not set
                if (!localStorage.getItem('trackingSet')) {
                    showTrackingDialog();
                }
                
                // Request necessary permissions
                await requestPermissions();
                
                // Load initial data
                await loadInitialData();
                
                // Set up periodic data refresh
                setInterval(loadData, API_CONFIG.CACHE_TTL);
                
            } catch (error) {
                console.error('Initialization error:', error);
                showError('Failed to initialize application. Please refresh the page.');
            }
        });

        // Initialize theme based on user preference
        function initTheme() {
            if (appState.preferences.theme === 'dark' ||
                (appState.preferences.theme === 'system' && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
                document.body.classList.add('dark-mode');
                document.getElementById('theme-toggle').querySelector('span').textContent = 'Light';
            } else {
                document.body.classList.remove('dark-mode');
                document.getElementById('theme-toggle').querySelector('span').textContent = 'Dark';
            }
        }

        // Toggle between light and dark theme
        function toggleTheme() {
            const isDark = document.body.classList.toggle('dark-mode');
            const themeToggle = document.getElementById('theme-toggle').querySelector('span');

            if (isDark) {
                themeToggle.textContent = 'Light';
                appState.preferences.theme = 'dark';
            } else {
                themeToggle.textContent = 'Dark';
                appState.preferences.theme = 'light';
            }
            
            localStorage.setItem('theme', appState.preferences.theme);
            
            // Update map if it exists
            if (appState.map) {
                appState.map.invalidateSize();
            }
            
            logEvent('theme_toggled', {
                theme: appState.preferences.theme
            });
        }

        // Toggle between languages
        function toggleLanguage() {
            const languageToggle = document.getElementById('language-toggle').querySelector('span');
            const currentLang = languageToggle.textContent;
            const newLang = currentLang === 'EN' ? 'TL' : 'EN';

            languageToggle.textContent = newLang;
            appState.preferences.language = newLang.toLowerCase();
            localStorage.setItem('language', newLang.toLowerCase());

            // In a real implementation, we would update all text content here
            logEvent('language_toggled', {
                language: newLang
            });
        }

        // Initialize service worker
        async function initServiceWorker() {
            if ('serviceWorker' in navigator) {
                try {
                    appState.serviceWorkerRegistration = await navigator.serviceWorker.register('/sw.js', {
                        scope: '/',
                        updateViaCache: 'none'
                    });
                    
                    console.log('ServiceWorker registered:', appState.serviceWorkerRegistration);
                    
                    // Check for updates periodically
                    setInterval(() => {
                        appState.serviceWorkerRegistration.update().catch(err => {
                            console.error('ServiceWorker update failed:', err);
                        });
                    }, 3600000); // Check every hour
                    
                } catch (error) {
                    console.error('ServiceWorker registration failed:', error);
                    throw error;
                }
            }
        }

        // Initialize the flood map with Leaflet
        function initMap() {
            // Create map instance
            appState.map = L.map('flood-map', {
                preferCanvas: true,
                zoomControl: false,
                attributionControl: false,
                minZoom: MAP_CONFIG.MIN_ZOOM,
                maxZoom: MAP_CONFIG.MAX_ZOOM
            }).setView(MAP_CONFIG.DEFAULT_CENTER, MAP_CONFIG.DEFAULT_ZOOM);

            // Add base map layer
            L.tileLayer(MAP_CONFIG.TILE_LAYER, {
                attribution: MAP_CONFIG.ATTRIBUTION
            }).addTo(appState.map);

            // Add flood risk layer (initially empty)
            appState.floodLayer = L.layerGroup().addTo(appState.map);

            // Add evacuation centers layer
            appState.evacuationLayer = L.layerGroup().addTo(appState.map);

            // Initialize user location marker (hidden by default)
            appState.userMarker = L.circleMarker([0, 0], {
                radius: MAP_CONFIG.USER_MARKER_RADIUS,
                fillColor: MAP_CONFIG.USER_MARKER_COLOR,
                color: "#FFFFFF",
                weight: 2,
                opacity: 1,
                fillOpacity: 0.8
            });

            // Initialize zoom controls
            L.control.zoom({
                position: 'topright'
            }).addTo(appState.map);

            // Add scale control
            L.control.scale({
                imperial: false,
                position: 'bottomright'
            }).addTo(appState.map);

            // Add attribution
            L.control.attribution({
                position: 'bottomleft',
                prefix: '<a href="https://agos.ph">Agos PH</a> | <a href="https://openstreetmap.org">OSM</a>'
            }).addTo(appState.map);
        }

        // Initialize charts
        function initCharts() {
            // Rainfall chart
            const rainfallCtx = document.getElementById('rainfall-chart').getContext('2d');
            appState.charts.rainfallChart = new Chart(rainfallCtx, {
                type: 'bar',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Rainfall (mm)',
                        data: [],
                        backgroundColor: '#1976D2',
                        borderColor: '#1565C0',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'mm'
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: false
                        }
                    }
                }
            });

            // Forecast chart
            const forecastCtx = document.getElementById('forecast-chart').getContext('2d');
            appState.charts.forecastChart = new Chart(forecastCtx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Water Level (cm)',
                        data: [],
                        fill: false,
                        backgroundColor: '#1976D2',
                        borderColor: '#1976D2',
                        tension: 0.4,
                        borderWidth: 3
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'cm'
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: false
                        }
                    }
                }
            });
        }

        // Initialize event listeners
        function initEventListeners() {
            // Theme toggle
            document.getElementById('theme-toggle').addEventListener('click', toggleTheme);

            // Language toggle
            document.getElementById('language-toggle').addEventListener('click', toggleLanguage);

            // Search functionality
            document.getElementById('search-btn').addEventListener('click', handleSearch);
            document.getElementById('location-search').addEventListener('keypress', function(e) {
                if (e.key === 'Enter') handleSearch();
            });

            // Map controls
            document.getElementById('locate-me').addEventListener('click', locateUser);
            document.getElementById('zoom-in').addEventListener('click', () => appState.map.zoomIn());
            document.getElementById('zoom-out').addEventListener('click', () => appState.map.zoomOut());

            // Emergency actions
            document.getElementById('view-evac-routes').addEventListener('click', showEvacuationRoutes);
            document.getElementById('call-emergency').addEventListener('click', showEmergencyContacts);

            // Install prompt
            window.addEventListener('beforeinstallprompt', (e) => {
                e.preventDefault();
                appState.deferredPrompt = e;
                showInstallPrompt();
            });

            document.getElementById('install-btn').addEventListener('click', () => {
                hideInstallPrompt();
                if (appState.deferredPrompt) {
                    appState.deferredPrompt.prompt();
                    appState.deferredPrompt.userChoice.then((choiceResult) => {
                        if (choiceResult.outcome === 'accepted') {
                            logEvent('install_accepted');
                        } else {
                            logEvent('install_declined');
                        }
                        appState.deferredPrompt = null;
                    });
                }
            });

            document.getElementById('dismiss-btn').addEventListener('click', () => {
                hideInstallPrompt();
                logEvent('install_dismissed');
            });

            // Notification prompts
            document.getElementById('enable-notifications').addEventListener('click', enableNotifications);
            document.getElementById('dismiss-notifications').addEventListener('click', () => {
                hideNotificationPrompt();
                logEvent('notifications_dismissed');
            });

            // Emergency modal
            document.getElementById('emergency-modal-close').addEventListener('click', hideEmergencyModal);
            document.getElementById('emergency-modal-confirm').addEventListener('click', hideEmergencyModal);

            // Bottom sheet
            document.getElementById('bottom-sheet-close').addEventListener('click', hideBottomSheet);
            document.getElementById('bottom-sheet-overlay').addEventListener('click', hideBottomSheet);

            // Permission dialogs
            document.getElementById('grant-location').addEventListener('click', grantLocationPermission);
            document.getElementById('deny-location').addEventListener('click', denyLocationPermission);

            // Tracking dialog
            document.getElementById('tracking-confirm').addEventListener('click', saveTrackingPreferences);
            document.getElementById('tracking-cancel').addEventListener('click', hideTrackingDialog);

            // Online/offline detection
            window.addEventListener('online', handleOnlineStatusChange);
            window.addEventListener('offline', handleOnlineStatusChange);
        }

        // Request necessary permissions
        async function requestPermissions() {
            // Request location permission if not already granted
            if (appState.preferences.locationPermission === 'unset') {
                await showLocationPermissionDialog();
            }

            // Request notification permission if not already set
            if (appState.preferences.notifications === 'unset' &&
                !['denied', 'granted'].includes(Notification.permission)) {
                showNotificationPrompt();
            }
        }

        // Show location permission dialog
        function showLocationPermissionDialog() {
            return new Promise((resolve) => {
                document.getElementById('location-permission-dialog').style.display = 'block';

                const grantBtn = document.getElementById('grant-location');
                const denyBtn = document.getElementById('deny-location');

                const cleanup = () => {
                    grantBtn.removeEventListener('click', onGrant);
                    denyBtn.removeEventListener('click', onDeny);
                };

                const onGrant = () => {
                    cleanup();
                    document.getElementById('location-permission-dialog').style.display = 'none';
                    resolve(true);
                };

                const onDeny = () => {
                    cleanup();
                    document.getElementById('location-permission-dialog').style.display = 'none';
                    resolve(false);
                };

                grantBtn.addEventListener('click', onGrant);
                denyBtn.addEventListener('click', onDeny);
            });
        }

        // Grant location permission
        async function grantLocationPermission() {
            try {
                const position = await getCurrentPosition();
                appState.preferences.locationPermission = 'granted';
                localStorage.setItem('locationPermission', 'granted');
                document.getElementById('location-permission-dialog').style.display = 'none';

                // Update UI with user's location
                appState.currentLocation = {
                    lat: position.coords.latitude,
                    lng: position.coords.longitude,
                    name: 'Your Location'
                };

                // Center map on user's location
                appState.map.setView([position.coords.latitude, position.coords.longitude], 14);

                logEvent('location_permission_granted');
            } catch (error) {
                console.error('Error getting location:', error);
                appState.preferences.locationPermission = 'denied';
                localStorage.setItem('locationPermission', 'denied');
                document.getElementById('location-permission-dialog').style.display = 'none';
                logEvent('location_permission_denied');
            }
        }

        // Deny location permission
        function denyLocationPermission() {
            appState.preferences.locationPermission = 'denied';
            localStorage.setItem('locationPermission', 'denied');
            document.getElementById('location-permission-dialog').style.display = 'none';
            logEvent('location_permission_denied');
        }

        // Get current position with timeout
        function getCurrentPosition(timeout = 10000) {
            return new Promise((resolve, reject) => {
                if (!navigator.geolocation) {
                    reject(new Error('Geolocation not supported'));
                    return;
                }

                const options = {
                    enableHighAccuracy: true,
                    timeout: timeout,
                    maximumAge: 0
                };

                const success = (position) => resolve(position);
                const error = (err) => reject(err);

                navigator.geolocation.getCurrentPosition(success, error, options);
            });
        }

        // Show tracking transparency dialog
        function showTrackingDialog() {
            document.getElementById('tracking-dialog').style.display = 'block';
        }

        // Hide tracking transparency dialog
        function hideTrackingDialog() {
            document.getElementById('tracking-dialog').style.display = 'none';
        }

        // Save tracking preferences
        function saveTrackingPreferences() {
            const selectedOption = document.querySelector('input[name="tracking"]:checked').value;
            appState.preferences.tracking = selectedOption;
            localStorage.setItem('tracking', selectedOption);
            localStorage.setItem('trackingSet', 'true');
            hideTrackingDialog();
            logEvent('tracking_preferences_saved', {
                preference: selectedOption
            });
        }

        // Show install prompt
        function showInstallPrompt() {
            document.getElementById('install-prompt').style.display = 'flex';
        }

        // Hide install prompt
        function hideInstallPrompt() {
            document.getElementById('install-prompt').style.display = 'none';
        }

        // Show notification prompt
        function showNotificationPrompt() {
            document.getElementById('notification-prompt').style.display = 'flex';
        }

        // Hide notification prompt
        function hideNotificationPrompt() {
            document.getElementById('notification-prompt').style.display = 'none';
        }

        // Enable notifications
        function enableNotifications() {
            Notification.requestPermission().then(permission => {
                appState.preferences.notifications = permission;
                localStorage.setItem('notifications', permission);
                hideNotificationPrompt();

                if (permission === 'granted') {
                    logEvent('notifications_enabled');
                    // In a real implementation, we would subscribe to push notifications
                } else {
                    logEvent('notifications_denied');
                }
            });
        }

        // Show emergency modal
        function showEmergencyModal(title, content) {
            document.getElementById('emergency-modal-title').textContent = title;
            document.getElementById('emergency-modal-body').innerHTML = content;
            document.getElementById('emergency-modal').style.display = 'flex';
        }

        // Hide emergency modal
        function hideEmergencyModal() {
            document.getElementById('emergency-modal').style.display = 'none';
        }

        // Show bottom sheet
        function showBottomSheet(title, content) {
            document.getElementById('bottom-sheet-title').textContent = title;
            document.getElementById('bottom-sheet-content').innerHTML = content;
            document.getElementById('bottom-sheet').classList.add('active');
            document.getElementById('bottom-sheet-overlay').style.display = 'block';
        }

        // Hide bottom sheet
        function hideBottomSheet() {
            document.getElementById('bottom-sheet').classList.remove('active');
            document.getElementById('bottom-sheet-overlay').style.display = 'none';
        }

        // Handle online/offline status changes
        function handleOnlineStatusChange() {
            const isOnline = navigator.onLine;
            appState.offlineMode = !isOnline;

            if (isOnline) {
                document.getElementById('offline-indicator').style.display = 'none';
                // Try to refresh data when coming back online
                loadData();
            } else {
                document.getElementById('offline-indicator').style.display = 'block';
            }

            logEvent('connection_change', {
                online: isOnline
            });
        }

        // Check connectivity
        function checkConnectivity() {
            handleOnlineStatusChange();
        }

        // Load initial data
        async function loadInitialData() {
            showLoading(true);

            try {
                // Check for cached data first
                const cachedData = getCachedData();
                if (cachedData) {
                    updateAppState(cachedData);
                    updateUI();
                }

                // Then load fresh data
                await loadData();
            } catch (error) {
                console.error('Error loading initial data:', error);
                showError('Failed to load initial data. Using cached data if available.');
            } finally {
                showLoading(false);
            }
        }

        // Main data loading function
        async function loadData() {
            if (appState.offlineMode) {
                console.log('Offline mode - using cached data');
                return;
            }

            showLoading(true);

            try {
                // Load all data in parallel
                const [floodData, rainfallData, predictions, roads, evacuation, sensors] = await Promise.all([
                    fetchFloodData(),
                    fetchRainfallData(),
                    fetchPredictions(),
                    fetchAffectedRoads(),
                    fetchEvacuationCenters(),
                    fetchSensorData()
                ]);

                // Process and validate all data
                const processedData = {
                    floodData: processFloodData(floodData),
                    rainfallData: processRainfallData(rainfallData),
                    predictions: processPredictions(predictions),
                    affectedRoads: processRoadData(roads),
                    evacuationCenters: processEvacuationData(evacuation),
                    sensorData: processSensorData(sensors),
                    lastUpdate: new Date(),
                    dataStatus: 'live'
                };

                // Update app state and UI
                updateAppState(processedData);
                updateUI();
                
                // Cache the data
                cacheData(processedData);
                
                // Check for emergency conditions
                checkForEmergencies();
                
                return true;
                
            } catch (error) {
                console.error('Error loading data:', error);
                appState.dataStatus = 'error';
                showError('Failed to load latest data. Using cached data if available.');
                return false;
            } finally {
                showLoading(false);
            }
        }

        // Fetch flood data from API
        async function fetchFloodData() {
            const url = `${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.FLOOD_DATA}`;
            const response = await fetchWithRetry(url);
            return response.json();
        }

        // Fetch rainfall data from API
        async function fetchRainfallData() {
            const url = `${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.RAINFALL}`;
            const response = await fetchWithRetry(url);
            return response.json();
        }

        // Fetch predictions from API
        async function fetchPredictions() {
            const url = `${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.PREDICTIONS}`;
            const response = await fetchWithRetry(url);
            return response.json();
        }

        // Fetch affected roads from API
        async function fetchAffectedRoads() {
            const url = `${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.ROADS}`;
            const response = await fetchWithRetry(url);
            return response.json();
        }

        // Fetch evacuation centers from API
        async function fetchEvacuationCenters() {
            const url = `${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.EVACUATION}`;
            const response = await fetchWithRetry(url);
            return response.json();
        }

        // Fetch sensor data from API
        async function fetchSensorData() {
            const url = `${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.SENSORS}`;
            const response = await fetchWithRetry(url);
            return response.json();
        }

        // Fetch with retry logic
        async function fetchWithRetry(url, options = {}, retries = API_CONFIG.MAX_RETRIES) {
            try {
                const response = await fetchWithTimeout(url, options);
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                return response;
                
            } catch (error) {
                if (retries > 0) {
                    console.log(`Retrying fetch (${API_CONFIG.MAX_RETRIES - retries + 1}/${API_CONFIG.MAX_RETRIES})`);
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    return fetchWithRetry(url, options, retries - 1);
                } else {
                    throw error;
                }
            }
        }

        // Fetch with timeout
        async function fetchWithTimeout(resource, options = {}) {
            const {
                timeout = API_CONFIG.TIMEOUT
            } = options;

            const controller = new AbortController();
            const id = setTimeout(() => controller.abort(), timeout);

            const response = await fetch(resource, {
                ...options,
                signal: controller.signal,
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${API_CONFIG.API_KEY}`
                }
            });

            clearTimeout(id);

            return response;
        }

        // Process flood data
        function processFloodData(data) {
            if (!data || !Array.isArray(data.locations)) {
                throw new Error('Invalid flood data format');
            }

            return {
                locations: data.locations.map(location => ({
                    id: location.id,
                    name: location.name,
                    coordinates: location.coordinates,
                    waterLevel: location.waterLevel,
                    rainfall: location.rainfall,
                    trend: location.trend,
                    riskLevel: calculateRiskLevel(location.waterLevel),
                    lastUpdated: new Date(location.lastUpdated),
                    sensors: location.sensors || []
                })),
                lastUpdated: new Date(data.lastUpdated)
            };
        }

        // Process rainfall data
        function processRainfallData(data) {
            if (!data || !Array.isArray(data.daily) || !Array.isArray(data.hourly)) {
                throw new Error('Invalid rainfall data format');
            }

            return {
                daily: data.daily.map(day => ({
                    day: day.day,
                    rainfall: day.rainfall
                })),
                hourly: data.hourly.map(hour => ({
                    hour: hour.hour,
                    level: hour.level
                })),
                lastUpdated: new Date(data.lastUpdated)
            };
        }

        // Process predictions
        function processPredictions(data) {
            if (!data || typeof data.timeToFlood !== 'string' || typeof data.riskLevel !== 'string') {
                throw new Error('Invalid predictions data format');
            }

            return {
                timeToFlood: data.timeToFlood,
                riskLevel: data.riskLevel,
                confidence: data.confidence,
                lastUpdated: new Date(data.lastUpdated)
            };
        }

        // Process road data
        function processRoadData(data) {
            if (!data || !Array.isArray(data.roads)) {
                throw new Error('Invalid road data format');
            }

            return {
                roads: data.roads.map(road => ({
                    id: road.id,
                    name: road.name,
                    status: road.status,
                    coordinates: road.coordinates,
                    lastUpdated: new Date(road.lastUpdated)
                })),
                lastUpdated: new Date(data.lastUpdated)
            };
        }

        // Process evacuation data
        function processEvacuationData(data) {
            if (!data || !Array.isArray(data.centers)) {
                throw new Error('Invalid evacuation data format');
            }

            return {
                centers: data.centers.map(center => ({
                    id: center.id,
                    name: center.name,
                    coordinates: center.coordinates,
                    capacity: center.capacity,
                    currentOccupancy: center.currentOccupancy,
                    distance: center.distance,
                    lastUpdated: new Date(center.lastUpdated)
                })),
                lastUpdated: new Date(data.lastUpdated)
            };
        }

        // Process sensor data
        function processSensorData(data) {
            if (!data || !Array.isArray(data.sensors)) {
                throw new Error('Invalid sensor data format');
            }

            return {
                sensors: data.sensors.map(sensor => ({
                    id: sensor.id,
                    type: sensor.type,
                    value: sensor.value,
                    unit: sensor.unit,
                    trend: sensor.trend,
                    lastUpdated: new Date(sensor.lastUpdated)
                })),
                lastUpdated: new Date(data.lastUpdated)
            };
        }

        // Calculate risk level
        function calculateRiskLevel(waterLevel) {
            if (waterLevel >= FLOOD_RISK_LEVELS.EXTREME.threshold) return 'extreme';
            if (waterLevel >= FLOOD_RISK_LEVELS.HIGH.threshold) return 'high';
            if (waterLevel >= FLOOD_RISK_LEVELS.MODERATE.threshold) return 'moderate';
            return 'low';
        }

        // Get cached data
        function getCachedData() {
            const cachedData = localStorage.getItem('floodDataCache');
            if (!cachedData) return null;

            try {
                const parsedData = JSON.parse(cachedData);
                const cacheAge = new Date() - new Date(parsedData.lastUpdate);

                if (cacheAge > API_CONFIG.CACHE_TTL) {
                    localStorage.removeItem('floodDataCache');
                    return null;
                }

                return parsedData;
            } catch (e) {
                console.error('Error parsing cached data:', e);
                return null;
            }
        }

        // Cache data
        function cacheData(data) {
            try {
                localStorage.setItem('floodDataCache', JSON.stringify(data));
            } catch (e) {
                console.error('Error caching data:', e);
            }
        }

        // Update app state
        function updateAppState(newState) {
            appState.floodData = newState.floodData || appState.floodData;
            appState.rainfallData = newState.rainfallData || appState.rainfallData;
            appState.predictions = newState.predictions || appState.predictions;
            appState.affectedRoads = newState.affectedRoads || appState.affectedRoads;
            appState.evacuationCenters = newState.evacuationCenters || appState.evacuationCenters;
            appState.sensorData = newState.sensorData || appState.sensorData;
            appState.lastUpdate = newState.lastUpdate || appState.lastUpdate;
            appState.dataStatus = newState.dataStatus || appState.dataStatus;
        }

        // Update UI
        function updateUI() {
            updateLocationInfo();
            updateFloodLayer();
            updateEvacuationLayer();
            updateCharts();
            updateRoadAlerts();
            updateHotspotsList();
            updateEvacuationCentersList();
            updateSensorData();
            updatePredictions();
            updateLastUpdated();
        }

        // Update location info
        function updateLocationInfo() {
            if (!appState.currentLocation) {
                // Default to map center if no location selected
                const center = appState.map.getCenter();
                appState.currentLocation = {
                    lat: center.lat,
                    lng: center.lng,
                    name: 'Current View'
                };
            }

            // Find nearest flood data point
            const nearestLocation = findNearestLocation(appState.currentLocation);

            if (nearestLocation) {
                appState.selectedLocation = nearestLocation;
                
                document.getElementById('selected-location').textContent = nearestLocation.name;
                document.getElementById('current-risk').textContent = nearestLocation.riskLevel.toUpperCase();
                document.getElementById('current-risk').className = `data-value ${nearestLocation.riskLevel}-risk`;
                document.getElementById('rainfall-value').textContent = `${nearestLocation.rainfall} mm/hr`;
                document.getElementById('water-level').textContent = `${nearestLocation.waterLevel} cm`;
                document.getElementById('flood-depth').textContent = getFloodDepthDescription(nearestLocation.waterLevel);
                document.getElementById('location-updated').textContent = `Updated: ${formatTime(nearestLocation.lastUpdated)}`;

                // Show location info panel
                document.getElementById('location-info').style.display = 'block';
            }
        }

        // Get flood depth description
        function getFloodDepthDescription(waterLevel) {
            if (waterLevel >= 100) return 'Dangerously Deep (100cm+)';
            if (waterLevel >= 60) return 'Waist-high (60-100cm)';
            if (waterLevel >= 30) return 'Knee-high (30-60cm)';
            if (waterLevel >= 15) return 'Ankle-high (15-30cm)';
            return 'Minimal (<15cm)';
        }

        // Find nearest location to coordinates
        function findNearestLocation(coords) {
            if (!appState.floodData || !appState.floodData.locations || !appState.floodData.locations.length) {
                return null;
            }

            let nearest = null;
            let minDistance = Infinity;

            appState.floodData.locations.forEach(location => {
                if (!location.coordinates) return;

                const center = getPolygonCenter(location.coordinates);
                const distance = calculateDistance(
                    coords.lat, coords.lng,
                    center.lat, center.lng
                );

                if (distance < minDistance) {
                    minDistance = distance;
                    nearest = location;
                }
            });

            return nearest;
        }

        // Calculate distance between two points in km
        function calculateDistance(lat1, lon1, lat2, lon2) {
            const R = 6371; // Radius of the earth in km
            const dLat = deg2rad(lat2 - lat1);
            const dLon = deg2rad(lon2 - lon1);
            const a = 
                Math.sin(dLat/2) * Math.sin(dLat/2) +
                Math.cos(deg2rad(lat1)) * Math.cos(deg2rad(lat2)) * 
                Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c; // Distance in km
        }

        function deg2rad(deg) {
            return deg * (Math.PI/180);
        }

        // Get center of polygon
        function getPolygonCenter(coordinates) {
            let latSum = 0;
            let lngSum = 0;
            let count = 0;

            coordinates.forEach(point => {
                if (Array.isArray(point[0])) {
                    point.forEach(p => {
                        latSum += p[0];
                        lngSum += p[1];
                        count++;
                    });
                } else {
                    latSum += point[0];
                    lngSum += point[1];
                    count++;
                }
            });

            return {
                lat: latSum / count,
                lng: lngSum / count
            };
        }

        // Update flood layer on map
        function updateFloodLayer() {
            if (!appState.floodData || !appState.map) return;

            // Clear previous layers
            appState.floodLayer.clearLayers();

            // Add new flood polygons
            appState.floodData.locations.forEach(location => {
                if (!location.coordinates) return;

                const color = FLOOD_RISK_LEVELS[location.riskLevel]?.color || '#1976D2';
                const polygon = L.polygon(location.coordinates, {
                    color: color,
                    fillOpacity: MAP_CONFIG.FLOOD_LAYER_OPACITY,
                    weight: MAP_CONFIG.FLOOD_LAYER_WEIGHT
                }).addTo(appState.floodLayer);

                // Add popup with location info
                polygon.bindPopup(`
                    <h4>${location.name}</h4>
                    <p>Water Level: ${location.waterLevel} cm</p>
                    <p>Risk: <span class="${location.riskLevel}-risk">${location.riskLevel.toUpperCase()}</span></p>
                    <p>Updated: ${formatTime(location.lastUpdated)}</p>
                    <button onclick="window.zoomToLocation('${location.id}')">View Details</button>
                `);
            });
        }

        // Update evacuation layer
        function updateEvacuationLayer() {
            if (!appState.evacuationCenters || !appState.map) return;

            // Clear previous layers
            appState.evacuationLayer.clearLayers();

            // Add new evacuation centers
            appState.evacuationCenters.centers.forEach(center => {
                if (!center.coordinates) return;

                const icon = L.divIcon({
                    className: 'evacuation-icon',
                    html: `<i class="material-icons" style="color: ${MAP_CONFIG.EVAC_MARKER_COLOR}; font-size: 24px;">${MAP_CONFIG.EVAC_MARKER_ICON}</i>`,
                    iconSize: [24, 24],
                    iconAnchor: [12, 24]
                });

                const marker = L.marker(center.coordinates, {
                    icon
                }).addTo(appState.evacuationLayer);

                // Add popup with center info
                marker.bindPopup(`
                    <h4>${center.name}</h4>
                    <p>Capacity: ${center.capacity} people</p>
                    <p>Current: ${center.currentOccupancy} people</p>
                    <p>Distance: ${center.distance}</p>
                `);
            });
        }

        // Update charts
        function updateCharts() {
            if (!appState.rainfallData) return;

            // Update rainfall chart
            appState.charts.rainfallChart.data.labels = appState.rainfallData.daily.map(d => d.day);
            appState.charts.rainfallChart.data.datasets[0].data = appState.rainfallData.daily.map(d => d.rainfall);
            appState.charts.rainfallChart.update();

            // Update forecast chart
            appState.charts.forecastChart.data.labels = appState.rainfallData.hourly.map(h => h.hour);
            appState.charts.forecastChart.data.datasets[0].data = appState.rainfallData.hourly.map(h => h.level);
            appState.charts.forecastChart.update();
        }

        // Update road alerts
        function updateRoadAlerts() {
            if (!appState.affectedRoads) return;

            const roadAlertsContainer = document.getElementById('road-alerts');
            roadAlertsContainer.innerHTML = '';

            appState.affectedRoads.roads.forEach(road => {
                const alertDiv = document.createElement('div');
                alertDiv.className = 'road-alert';
                alertDiv.innerHTML = `
                    <i class="material-icons">warning</i>
                    <div>
                        <div class="road-name">${road.name}</div>
                        <div class="road-status">${road.status}</div>
                    </div>
                `;
                alertDiv.addEventListener('click', () => {
                    showBottomSheet(road.name, `
                        <p><strong>Status:</strong> ${road.status}</p>
                        <p><strong>Last Updated:</strong> ${formatTime(road.lastUpdated)}</p>
                        <button class="modal-btn modal-btn-primary" onclick="window.zoomToRoad('${road.id}')">View on Map</button>
                    `);
                });
                roadAlertsContainer.appendChild(alertDiv);
            });
        }

        // Update hotspots list
        function updateHotspotsList() {
            if (!appState.floodData) return;

            const hotspotsContainer = document.getElementById('hotspots-list');
            hotspotsContainer.innerHTML = '';

            // Sort locations by water level (highest first)
            const hotspots = [...appState.floodData.locations]
                .sort((a, b) => b.waterLevel - a.waterLevel)
                .slice(0, 5); // Top 5 hotspots

            hotspots.forEach(location => {
                const hotspotDiv = document.createElement('div');
                hotspotDiv.className = 'sensor-item';
                hotspotDiv.innerHTML = `
                    <div class="sensor-icon">
                        <i class="material-icons">warning</i>
                    </div>
                    <div class="sensor-info">
                        <h4>${location.name}</h4>
                        <div class="sensor-value ${location.riskLevel}-risk">${location.waterLevel} cm (${location.riskLevel.toUpperCase()})</div>
                    </div>
                `;
                hotspotDiv.addEventListener('click', () => {
                    window.zoomToLocation(location.id);
                });
                hotspotsContainer.appendChild(hotspotDiv);
            });
        }

        // Update evacuation centers list
        function updateEvacuationCentersList() {
            if (!appState.evacuationCenters) return;

            const evacContainer = document.getElementById('evacuation-centers');
            evacContainer.innerHTML = '';

            appState.evacuationCenters.centers.forEach(center => {
                const centerDiv = document.createElement('div');
                centerDiv.className = 'sensor-item';
                centerDiv.innerHTML = `
                    <div class="sensor-icon">
                        <i class="material-icons">place</i>
                    </div>
                    <div class="sensor-info">
                        <h4>${center.name}</h4>
                        <div class="sensor-value">${center.distance} â€¢ ${center.currentOccupancy}/${center.capacity}</div>
                    </div>
                `;
                centerDiv.addEventListener('click', () => {
                    showBottomSheet(center.name, `
                        <p><strong>Distance:</strong> ${center.distance}</p>
                        <p><strong>Capacity:</strong> ${center.currentOccupancy}/${center.capacity} people</p>
                        <p><strong>Status:</strong> ${center.currentOccupancy >= center.capacity ? 'Full' : 'Available'}</p>
                        <button class="modal-btn modal-btn-primary" onclick="window.zoomToEvacuationCenter('${center.id}')">View on Map</button>
                    `);
                });
                evacContainer.appendChild(centerDiv);
            });
        }

        // Update sensor data
        function updateSensorData() {
            if (!appState.sensorData) return;

            const sensorTypes = {
                'rain-rate': 'water_drop',
                'rise-velocity': 'trending_up',
                'last-heavy-rain': 'calendar_today',
                'vs-average': 'compare'
            };

            Object.keys(sensorTypes).forEach(id => {
                const sensor = appState.sensorData.sensors.find(s => s.type === id);
                if (sensor) {
                    const element = document.getElementById(id);
                    if (element) {
                        element.textContent = `${sensor.value} ${sensor.unit || ''}`;
                    }
                }
            });
        }

        // Update predictions
        function updatePredictions() {
            if (!appState.predictions) return;

            document.getElementById('prediction-time').textContent = appState.predictions.timeToFlood;
            document.getElementById('prediction-level').textContent = appState.predictions.riskLevel.toUpperCase();
            document.getElementById('prediction-level').className = `prediction-level ${appState.predictions.riskLevel}-risk`;
            document.getElementById('prediction-details').textContent = `Confidence: ${appState.predictions.confidence}%`;
        }

        // Update last updated time
        function updateLastUpdated() {
            if (appState.lastUpdate) {
                document.getElementById('update-time').textContent = formatDateTime(appState.lastUpdate);
            }
        }

        // Check for emergency conditions
        function checkForEmergencies() {
            if (!appState.selectedLocation) return;

            if (appState.selectedLocation.riskLevel === 'high' || appState.selectedLocation.riskLevel === 'extreme') {
                showEmergencyAlert(appState.selectedLocation);
            }
        }

        // Show emergency alert
        function showEmergencyAlert(location) {
            const emergencyCard = document.getElementById('emergency-card');
            const emergencyContent = document.getElementById('emergency-alert-content');

            emergencyContent.innerHTML = `
                <p>Flood warning for ${location.name}. Water level is ${location.waterLevel} cm (${location.riskLevel.toUpperCase()} risk).</p>
                <p>${getEmergencyAdvice(location.riskLevel)}</p>
            `;

            emergencyCard.style.display = 'block';
            emergencyCard.classList.add('animate__animated', 'animate__shakeX');

            // Remove animation class after it completes
            setTimeout(() => {
                emergencyCard.classList.remove('animate__animated', 'animate__shakeX');
            }, 1000);

            // Show notification if permission granted
            if (Notification.permission === 'granted') {
                new Notification('FLOOD WARNING', {
                    body: `Flood warning for ${location.name}. Water level is ${location.waterLevel} cm.`,
                    icon: 'icons/icon-192x192.png'
                });
            }

            logEvent('emergency_alert_shown', {
                location: location.name,
                waterLevel: location.waterLevel,
                riskLevel: location.riskLevel
            });
        }

        // Get emergency advice
        function getEmergencyAdvice(riskLevel) {
            switch (riskLevel) {
                case 'extreme':
                    return 'Immediate evacuation recommended. Move to higher ground or designated evacuation center.';
                case 'high':
                    return 'Prepare to evacuate. Gather essential items and monitor water levels closely.';
                case 'moderate':
                    return 'Stay alert. Avoid low-lying areas and prepare emergency supplies.';
                default:
                    return 'Monitor situation. Be prepared to move if conditions worsen.';
            }
        }

        // Handle search
        async function handleSearch() {
            const searchInput = document.getElementById('location-search');
            const query = searchInput.value.trim();

            if (!query) return;

            document.getElementById('search-text').style.display = 'none';
            document.getElementById('search-spinner').style.display = 'inline-block';

            try {
                // In a real implementation, we would call a geocoding API
                const response = await fetch(`${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.GEOLOCATION}?query=${encodeURIComponent(query)}`, {
                    headers: {
                        'Authorization': `Bearer ${API_CONFIG.API_KEY}`
                    }
                });
                
                if (!response.ok) {
                    throw new Error('Location not found');
                }
                
                const location = await response.json();
                
                appState.currentLocation = {
                    lat: location.latitude,
                    lng: location.longitude,
                    name: location.name
                };

                appState.map.setView([location.latitude, location.longitude], 14);
                updateLocationInfo();

                logEvent('location_searched', {
                    query,
                    found: true
                });
                
            } catch (error) {
                console.error('Search error:', error);
                
                showBottomSheet('Search Results', `
                    <p>No matches found for "${query}".</p>
                    <p>Try searching for nearby barangays or cities.</p>
                `);

                logEvent('location_searched', {
                    query,
                    found: false,
                    error: error.message
                });
                
            } finally {
                document.getElementById('search-text').style.display = 'inline';
                document.getElementById('search-spinner').style.display = 'none';
            }
        }

        // Locate user
        async function locateUser() {
            if (appState.preferences.locationPermission === 'denied') {
                showBottomSheet('Location Access', `
                    <p>You've previously denied location access.</p>
                    <p>Please enable location permissions in your browser settings to use this feature.</p>
                `);
                return;
            }

            showLoading(true);

            try {
                const position = await getCurrentPosition();

                appState.currentLocation = {
                    lat: position.coords.latitude,
                    lng: position.coords.longitude,
                    name: 'Your Location'
                };

                appState.map.setView([position.coords.latitude, position.coords.longitude], 14);

                // Update user marker
                appState.userMarker.setLatLng([position.coords.latitude, position.coords.longitude]);
                appState.userMarker.addTo(appState.map);

                updateLocationInfo();

                logEvent('location_updated', {
                    lat: position.coords.latitude,
                    lng: position.coords.longitude
                });
                
            } catch (error) {
                console.error('Location error:', error);
                
                showBottomSheet('Location Error', `
                    <p>Unable to determine your location.</p>
                    <p>${error.message}</p>
                `);

                logEvent('location_error', {
                    error: error.message
                });
                
            } finally {
                showLoading(false);
            }
        }

        // Show evacuation routes
        function showEvacuationRoutes() {
            if (!appState.currentLocation || !appState.evacuationCenters) return;

            const nearestEvacCenter = findNearestEvacuationCenter(appState.currentLocation);

            if (nearestEvacCenter) {
                showBottomSheet('Nearest Evacuation Center', `
                    <p><strong>Name:</strong> ${nearestEvacCenter.name}</p>
                    <p><strong>Distance:</strong> ${nearestEvacCenter.distance}</p>
                    <p><strong>Capacity:</strong> ${nearestEvacCenter.currentOccupancy}/${nearestEvacCenter.capacity}</p>
                    <p><strong>Status:</strong> ${nearestEvacCenter.currentOccupancy >= nearestEvacCenter.capacity ? 'Full' : 'Available'}</p>
                    <button class="modal-btn modal-btn-primary" onclick="window.zoomToEvacuationCenter('${nearestEvacCenter.id}')">View on Map</button>
                `);

                logEvent('evacuation_routes_viewed', {
                    center: nearestEvacCenter.name,
                    distance: nearestEvacCenter.distance
                });
            }
        }

        // Find nearest evacuation center
        function findNearestEvacuationCenter(coords) {
            if (!appState.evacuationCenters || !appState.evacuationCenters.centers.length) {
                return null;
            }

            let nearest = null;
            let minDistance = Infinity;

            appState.evacuationCenters.centers.forEach(center => {
                if (!center.coordinates) return;

                const distance = calculateDistance(
                    coords.lat, coords.lng,
                    center.coordinates[0], center.coordinates[1]
                );

                if (distance < minDistance) {
                    minDistance = distance;
                    nearest = center;
                }
            });

            return nearest;
        }

        // Show emergency contacts
        function showEmergencyContacts() {
            showBottomSheet('Emergency Contacts', `
                <p><strong>National Emergency Hotline:</strong> 911</p>
                <p><strong>NDRRMC:</strong> (02) 8911-6606</p>
                <p><strong>Red Cross:</strong> 143 or (02) 8527-7927</p>
                <p><strong>MMDA:</strong> 136</p>
                <p><strong>PNP:</strong> 117 or (02) 8723-0401</p>
            `);

            logEvent('emergency_contacts_viewed');
        }

        // Show loading overlay
        function showLoading(show) {
            document.getElementById('loading-overlay').style.display = show ? 'flex' : 'none';
        }

        // Show error message
        function showError(message) {
            const errorDiv = document.createElement('div');
            errorDiv.className = 'road-alert';
            errorDiv.innerHTML = `
                <i class="material-icons">error</i>
                <div>
                    <div class="road-name">Error</div>
                    <div class="road-status">${message}</div>
                </div>
            `;
            
            // Prepend to dashboard
            const dashboard = document.querySelector('.dashboard');
            if (dashboard) {
                dashboard.prepend(errorDiv);
            }
        }

        // Format time
        function formatTime(date) {
            if (!(date instanceof Date)) date = new Date(date);
            return date.toLocaleTimeString([], {
                hour: '2-digit',
                minute: '2-digit'
            });
        }

        // Format date and time
        function formatDateTime(date) {
            if (!(date instanceof Date)) date = new Date(date);
            return date.toLocaleString([], {
                year: 'numeric',
                month: 'short',
                day: 'numeric',
                hour: '2-digit',
                minute: '2-digit'
            });
        }

        // Log event (analytics)
        function logEvent(eventName, metadata = {}) {
            if (appState.preferences.tracking === 'essential') return;

            const eventData = {
                event: eventName,
                timestamp: new Date().toISOString(),
                location: appState.currentLocation,
                ...metadata
            };

            // In a real implementation, send to analytics service
            console.log('Event:', eventData);
            
            // Example of sending to analytics endpoint
            if (appState.preferences.tracking !== 'essential' && !appState.offlineMode) {
                fetch(`${API_CONFIG.BASE_URL}/analytics`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${API_CONFIG.API_KEY}`
                    },
                    body: JSON.stringify(eventData)
                }).catch(err => {
                    console.error('Error sending analytics:', err);
                });
            }
        }

        // Global functions
        window.zoomToLocation = function(locationId) {
            const location = appState.floodData.locations.find(loc => loc.id === locationId);
            if (location && location.coordinates) {
                appState.map.fitBounds(location.coordinates);
                appState.currentLocation = {
                    lat: location.coordinates[0][0],
                    lng: location.coordinates[0][1],
                    name: location.name
                };
                updateLocationInfo();
                hideBottomSheet();
            }
        };

        window.zoomToRoad = function(roadId) {
            const road = appState.affectedRoads.roads.find(r => r.id === roadId);
            if (road && road.coordinates) {
                appState.map.fitBounds(road.coordinates);
                hideBottomSheet();
            }
        };

        window.zoomToEvacuationCenter = function(centerId) {
            const center = appState.evacuationCenters.centers.find(c => c.id === centerId);
            if (center && center.coordinates) {
                appState.map.setView(center.coordinates, 15);
                hideBottomSheet();
            }
        };

        // Show loading overlay
        window.showLoading = showLoading;
    </script>
</body>

</html>